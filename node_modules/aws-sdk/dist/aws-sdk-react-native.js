(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AWS"] = factory();
	else
		root["AWS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var AWS = __webpack_require__(2);

	__webpack_require__(49);
	module.exports = AWS;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var AWS = __webpack_require__(4);

	AWS.util.isBrowser = function() { return true; };
	AWS.util.isNode = function() { return false; };

	// react-native specific modules
	AWS.util.crypto.lib = __webpack_require__(5);
	AWS.util.Buffer = __webpack_require__(8).Buffer;
	AWS.util.url = __webpack_require__(15);
	AWS.util.querystring = __webpack_require__(18);
	AWS.util.realClock = __webpack_require__(21);
	AWS.util.environment = 'js-react-native';
	AWS.util.createEventStream = __webpack_require__(22).createEventStream;

	/**
	 * @api private
	 */
	module.exports = AWS;

	__webpack_require__(28);
	__webpack_require__(29);
	__webpack_require__(30);
	__webpack_require__(36);
	__webpack_require__(37);
	__webpack_require__(38);
	__webpack_require__(42);

	// Load the DOMParser XML parser
	AWS.XML.Parser = __webpack_require__(43);

	// Load the XHR HttpClient
	__webpack_require__(45);

	// add custom request event handlers
	var addContentType = __webpack_require__(48).addContentType;
	AWS.EventListeners.Core.addNamedListeners(function(add) {
	  add('ADD_CONTENT_TYPE', 'afterBuild', addContentType);
	});

	if (typeof process === 'undefined') {
	  process = {};
	}
	process.browser = true;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["AWS"] = factory();
		else
			root["AWS"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(1);


	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * The main AWS namespace
		 */
		var AWS = { util: __webpack_require__(2) };

		/**
		 * @api private
		 * @!macro [new] nobrowser
		 *   @note This feature is not supported in the browser environment of the SDK.
		 */
		var _hidden = {}; _hidden.toString(); // hack to parse macro

		/**
		 * @api private
		 */
		module.exports = AWS;

		AWS.util.update(AWS, {

		  /**
		   * @constant
		   */
		  VERSION: '2.1259.0',

		  /**
		   * @api private
		   */
		  Signers: {},

		  /**
		   * @api private
		   */
		  Protocol: {
		    Json: __webpack_require__(18),
		    Query: __webpack_require__(22),
		    Rest: __webpack_require__(26),
		    RestJson: __webpack_require__(27),
		    RestXml: __webpack_require__(28)
		  },

		  /**
		   * @api private
		   */
		  XML: {
		    Builder: __webpack_require__(29),
		    Parser: null // conditionally set based on environment
		  },

		  /**
		   * @api private
		   */
		  JSON: {
		    Builder: __webpack_require__(19),
		    Parser: __webpack_require__(20)
		  },

		  /**
		   * @api private
		   */
		  Model: {
		    Api: __webpack_require__(34),
		    Operation: __webpack_require__(35),
		    Shape: __webpack_require__(24),
		    Paginator: __webpack_require__(36),
		    ResourceWaiter: __webpack_require__(37)
		  },

		  /**
		   * @api private
		   */
		  apiLoader: __webpack_require__(38),

		  /**
		   * @api private
		   */
		  EndpointCache: __webpack_require__(39).EndpointCache
		});
		__webpack_require__(41);
		__webpack_require__(42);
		__webpack_require__(46);
		__webpack_require__(49);
		__webpack_require__(50);
		__webpack_require__(73);
		__webpack_require__(76);
		__webpack_require__(77);
		__webpack_require__(78);
		__webpack_require__(87);

		/**
		 * @readonly
		 * @return [AWS.SequentialExecutor] a collection of global event listeners that
		 *   are attached to every sent request.
		 * @see AWS.Request AWS.Request for a list of events to listen for
		 * @example Logging the time taken to send a request
		 *   AWS.events.on('send', function startSend(resp) {
		 *     resp.startTime = new Date().getTime();
		 *   }).on('complete', function calculateTime(resp) {
		 *     var time = (new Date().getTime() - resp.startTime) / 1000;
		 *     console.log('Request took ' + time + ' seconds');
		 *   });
		 *
		 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
		 */
		AWS.events = new AWS.SequentialExecutor();

		//create endpoint cache lazily
		AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
		  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
		}, true);


	/***/ }),
	/* 2 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/* eslint guard-for-in:0 */
		var AWS;

		/**
		 * A set of utility methods for use with the AWS SDK.
		 *
		 * @!attribute abort
		 *   Return this value from an iterator function {each} or {arrayEach}
		 *   to break out of the iteration.
		 *   @example Breaking out of an iterator function
		 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
		 *       if (key == 'b') return AWS.util.abort;
		 *     });
		 *   @see each
		 *   @see arrayEach
		 * @api private
		 */
		var util = {
		  environment: 'nodejs',
		  engine: function engine() {
		    if (util.isBrowser() && typeof navigator !== 'undefined') {
		      return navigator.userAgent;
		    } else {
		      var engine = process.platform + '/' + process.version;
		      if (process.env.AWS_EXECUTION_ENV) {
		        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
		      }
		      return engine;
		    }
		  },

		  userAgent: function userAgent() {
		    var name = util.environment;
		    var agent = 'aws-sdk-' + name + '/' + __webpack_require__(1).VERSION;
		    if (name === 'nodejs') agent += ' ' + util.engine();
		    return agent;
		  },

		  uriEscape: function uriEscape(string) {
		    var output = encodeURIComponent(string);
		    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

		    // AWS percent-encodes some extra non-standard characters in a URI
		    output = output.replace(/[*]/g, function(ch) {
		      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
		    });

		    return output;
		  },

		  uriEscapePath: function uriEscapePath(string) {
		    var parts = [];
		    util.arrayEach(string.split('/'), function (part) {
		      parts.push(util.uriEscape(part));
		    });
		    return parts.join('/');
		  },

		  urlParse: function urlParse(url) {
		    return util.url.parse(url);
		  },

		  urlFormat: function urlFormat(url) {
		    return util.url.format(url);
		  },

		  queryStringParse: function queryStringParse(qs) {
		    return util.querystring.parse(qs);
		  },

		  queryParamsToString: function queryParamsToString(params) {
		    var items = [];
		    var escape = util.uriEscape;
		    var sortedKeys = Object.keys(params).sort();

		    util.arrayEach(sortedKeys, function(name) {
		      var value = params[name];
		      var ename = escape(name);
		      var result = ename + '=';
		      if (Array.isArray(value)) {
		        var vals = [];
		        util.arrayEach(value, function(item) { vals.push(escape(item)); });
		        result = ename + '=' + vals.sort().join('&' + ename + '=');
		      } else if (value !== undefined && value !== null) {
		        result = ename + '=' + escape(value);
		      }
		      items.push(result);
		    });

		    return items.join('&');
		  },

		  readFileSync: function readFileSync(path) {
		    if (util.isBrowser()) return null;
		    return __webpack_require__(6).readFileSync(path, 'utf-8');
		  },

		  base64: {
		    encode: function encode64(string) {
		      if (typeof string === 'number') {
		        throw util.error(new Error('Cannot base64 encode number ' + string));
		      }
		      if (string === null || typeof string === 'undefined') {
		        return string;
		      }
		      var buf = util.buffer.toBuffer(string);
		      return buf.toString('base64');
		    },

		    decode: function decode64(string) {
		      if (typeof string === 'number') {
		        throw util.error(new Error('Cannot base64 decode number ' + string));
		      }
		      if (string === null || typeof string === 'undefined') {
		        return string;
		      }
		      return util.buffer.toBuffer(string, 'base64');
		    }

		  },

		  buffer: {
		    /**
		     * Buffer constructor for Node buffer and buffer pollyfill
		     */
		    toBuffer: function(data, encoding) {
		      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
		        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
		    },

		    alloc: function(size, fill, encoding) {
		      if (typeof size !== 'number') {
		        throw new Error('size passed to alloc must be a number.');
		      }
		      if (typeof util.Buffer.alloc === 'function') {
		        return util.Buffer.alloc(size, fill, encoding);
		      } else {
		        var buf = new util.Buffer(size);
		        if (fill !== undefined && typeof buf.fill === 'function') {
		          buf.fill(fill, undefined, undefined, encoding);
		        }
		        return buf;
		      }
		    },

		    toStream: function toStream(buffer) {
		      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

		      var readable = new (util.stream.Readable)();
		      var pos = 0;
		      readable._read = function(size) {
		        if (pos >= buffer.length) return readable.push(null);

		        var end = pos + size;
		        if (end > buffer.length) end = buffer.length;
		        readable.push(buffer.slice(pos, end));
		        pos = end;
		      };

		      return readable;
		    },

		    /**
		     * Concatenates a list of Buffer objects.
		     */
		    concat: function(buffers) {
		      var length = 0,
		          offset = 0,
		          buffer = null, i;

		      for (i = 0; i < buffers.length; i++) {
		        length += buffers[i].length;
		      }

		      buffer = util.buffer.alloc(length);

		      for (i = 0; i < buffers.length; i++) {
		        buffers[i].copy(buffer, offset);
		        offset += buffers[i].length;
		      }

		      return buffer;
		    }
		  },

		  string: {
		    byteLength: function byteLength(string) {
		      if (string === null || string === undefined) return 0;
		      if (typeof string === 'string') string = util.buffer.toBuffer(string);

		      if (typeof string.byteLength === 'number') {
		        return string.byteLength;
		      } else if (typeof string.length === 'number') {
		        return string.length;
		      } else if (typeof string.size === 'number') {
		        return string.size;
		      } else if (typeof string.path === 'string') {
		        return __webpack_require__(6).lstatSync(string.path).size;
		      } else {
		        throw util.error(new Error('Cannot determine length of ' + string),
		          { object: string });
		      }
		    },

		    upperFirst: function upperFirst(string) {
		      return string[0].toUpperCase() + string.substr(1);
		    },

		    lowerFirst: function lowerFirst(string) {
		      return string[0].toLowerCase() + string.substr(1);
		    }
		  },

		  ini: {
		    parse: function string(ini) {
		      var currentSection, map = {};
		      util.arrayEach(ini.split(/\r?\n/), function(line) {
		        line = line.split(/(^|\s)[;#]/)[0].trim(); // remove comments and trim
		        var isSection = line[0] === '[' && line[line.length - 1] === ']';
		        if (isSection) {
		          currentSection = line.substring(1, line.length - 1);
		          if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
		            throw util.error(
		              new Error('Cannot load profile name \'' + currentSection + '\' from shared ini file.')
		            );
		          }
		        } else if (currentSection) {
		          var indexOfEqualsSign = line.indexOf('=');
		          var start = 0;
		          var end = line.length - 1;
		          var isAssignment =
		            indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;

		          if (isAssignment) {
		            var name = line.substring(0, indexOfEqualsSign).trim();
		            var value = line.substring(indexOfEqualsSign + 1).trim();

		            map[currentSection] = map[currentSection] || {};
		            map[currentSection][name] = value;
		          }
		        }
		      });

		      return map;
		    }
		  },

		  fn: {
		    noop: function() {},
		    callback: function (err) { if (err) throw err; },

		    /**
		     * Turn a synchronous function into as "async" function by making it call
		     * a callback. The underlying function is called with all but the last argument,
		     * which is treated as the callback. The callback is passed passed a first argument
		     * of null on success to mimick standard node callbacks.
		     */
		    makeAsync: function makeAsync(fn, expectedArgs) {
		      if (expectedArgs && expectedArgs <= fn.length) {
		        return fn;
		      }

		      return function() {
		        var args = Array.prototype.slice.call(arguments, 0);
		        var callback = args.pop();
		        var result = fn.apply(null, args);
		        callback(result);
		      };
		    }
		  },

		  /**
		   * Date and time utility functions.
		   */
		  date: {

		    /**
		     * @return [Date] the current JavaScript date object. Since all
		     *   AWS services rely on this date object, you can override
		     *   this function to provide a special time value to AWS service
		     *   requests.
		     */
		    getDate: function getDate() {
		      if (!AWS) AWS = __webpack_require__(1);
		      if (AWS.config.systemClockOffset) { // use offset when non-zero
		        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
		      } else {
		        return new Date();
		      }
		    },

		    /**
		     * @return [String] the date in ISO-8601 format
		     */
		    iso8601: function iso8601(date) {
		      if (date === undefined) { date = util.date.getDate(); }
		      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
		    },

		    /**
		     * @return [String] the date in RFC 822 format
		     */
		    rfc822: function rfc822(date) {
		      if (date === undefined) { date = util.date.getDate(); }
		      return date.toUTCString();
		    },

		    /**
		     * @return [Integer] the UNIX timestamp value for the current time
		     */
		    unixTimestamp: function unixTimestamp(date) {
		      if (date === undefined) { date = util.date.getDate(); }
		      return date.getTime() / 1000;
		    },

		    /**
		     * @param [String,number,Date] date
		     * @return [Date]
		     */
		    from: function format(date) {
		      if (typeof date === 'number') {
		        return new Date(date * 1000); // unix timestamp
		      } else {
		        return new Date(date);
		      }
		    },

		    /**
		     * Given a Date or date-like value, this function formats the
		     * date into a string of the requested value.
		     * @param [String,number,Date] date
		     * @param [String] formatter Valid formats are:
		     #   * 'iso8601'
		     #   * 'rfc822'
		     #   * 'unixTimestamp'
		     * @return [String]
		     */
		    format: function format(date, formatter) {
		      if (!formatter) formatter = 'iso8601';
		      return util.date[formatter](util.date.from(date));
		    },

		    parseTimestamp: function parseTimestamp(value) {
		      if (typeof value === 'number') { // unix timestamp (number)
		        return new Date(value * 1000);
		      } else if (value.match(/^\d+$/)) { // unix timestamp
		        return new Date(value * 1000);
		      } else if (value.match(/^\d{4}/)) { // iso8601
		        return new Date(value);
		      } else if (value.match(/^\w{3},/)) { // rfc822
		        return new Date(value);
		      } else {
		        throw util.error(
		          new Error('unhandled timestamp format: ' + value),
		          {code: 'TimestampParserError'});
		      }
		    }

		  },

		  crypto: {
		    crc32Table: [
		     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
		     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
		     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
		     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
		     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
		     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
		     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
		     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
		     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
		     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
		     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
		     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
		     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
		     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
		     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
		     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
		     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
		     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
		     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
		     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
		     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
		     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
		     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
		     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
		     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
		     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
		     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
		     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
		     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
		     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
		     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
		     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
		     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
		     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
		     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
		     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
		     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
		     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
		     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
		     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
		     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
		     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
		     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
		     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
		     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
		     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
		     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
		     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
		     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
		     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
		     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
		     0x2D02EF8D],

		    crc32: function crc32(data) {
		      var tbl = util.crypto.crc32Table;
		      var crc = 0 ^ -1;

		      if (typeof data === 'string') {
		        data = util.buffer.toBuffer(data);
		      }

		      for (var i = 0; i < data.length; i++) {
		        var code = data.readUInt8(i);
		        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
		      }
		      return (crc ^ -1) >>> 0;
		    },

		    hmac: function hmac(key, string, digest, fn) {
		      if (!digest) digest = 'binary';
		      if (digest === 'buffer') { digest = undefined; }
		      if (!fn) fn = 'sha256';
		      if (typeof string === 'string') string = util.buffer.toBuffer(string);
		      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
		    },

		    md5: function md5(data, digest, callback) {
		      return util.crypto.hash('md5', data, digest, callback);
		    },

		    sha256: function sha256(data, digest, callback) {
		      return util.crypto.hash('sha256', data, digest, callback);
		    },

		    hash: function(algorithm, data, digest, callback) {
		      var hash = util.crypto.createHash(algorithm);
		      if (!digest) { digest = 'binary'; }
		      if (digest === 'buffer') { digest = undefined; }
		      if (typeof data === 'string') data = util.buffer.toBuffer(data);
		      var sliceFn = util.arraySliceFn(data);
		      var isBuffer = util.Buffer.isBuffer(data);
		      //Identifying objects with an ArrayBuffer as buffers
		      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

		      if (callback && typeof data === 'object' &&
		          typeof data.on === 'function' && !isBuffer) {
		        data.on('data', function(chunk) { hash.update(chunk); });
		        data.on('error', function(err) { callback(err); });
		        data.on('end', function() { callback(null, hash.digest(digest)); });
		      } else if (callback && sliceFn && !isBuffer &&
		                 typeof FileReader !== 'undefined') {
		        // this might be a File/Blob
		        var index = 0, size = 1024 * 512;
		        var reader = new FileReader();
		        reader.onerror = function() {
		          callback(new Error('Failed to read data.'));
		        };
		        reader.onload = function() {
		          var buf = new util.Buffer(new Uint8Array(reader.result));
		          hash.update(buf);
		          index += buf.length;
		          reader._continueReading();
		        };
		        reader._continueReading = function() {
		          if (index >= data.size) {
		            callback(null, hash.digest(digest));
		            return;
		          }

		          var back = index + size;
		          if (back > data.size) back = data.size;
		          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
		        };

		        reader._continueReading();
		      } else {
		        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
		          data = new util.Buffer(new Uint8Array(data));
		        }
		        var out = hash.update(data).digest(digest);
		        if (callback) callback(null, out);
		        return out;
		      }
		    },

		    toHex: function toHex(data) {
		      var out = [];
		      for (var i = 0; i < data.length; i++) {
		        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
		      }
		      return out.join('');
		    },

		    createHash: function createHash(algorithm) {
		      return util.crypto.lib.createHash(algorithm);
		    }

		  },

		  /** @!ignore */

		  /* Abort constant */
		  abort: {},

		  each: function each(object, iterFunction) {
		    for (var key in object) {
		      if (Object.prototype.hasOwnProperty.call(object, key)) {
		        var ret = iterFunction.call(this, key, object[key]);
		        if (ret === util.abort) break;
		      }
		    }
		  },

		  arrayEach: function arrayEach(array, iterFunction) {
		    for (var idx in array) {
		      if (Object.prototype.hasOwnProperty.call(array, idx)) {
		        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
		        if (ret === util.abort) break;
		      }
		    }
		  },

		  update: function update(obj1, obj2) {
		    util.each(obj2, function iterator(key, item) {
		      obj1[key] = item;
		    });
		    return obj1;
		  },

		  merge: function merge(obj1, obj2) {
		    return util.update(util.copy(obj1), obj2);
		  },

		  copy: function copy(object) {
		    if (object === null || object === undefined) return object;
		    var dupe = {};
		    // jshint forin:false
		    for (var key in object) {
		      dupe[key] = object[key];
		    }
		    return dupe;
		  },

		  isEmpty: function isEmpty(obj) {
		    for (var prop in obj) {
		      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
		        return false;
		      }
		    }
		    return true;
		  },

		  arraySliceFn: function arraySliceFn(obj) {
		    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
		    return typeof fn === 'function' ? fn : null;
		  },

		  isType: function isType(obj, type) {
		    // handle cross-"frame" objects
		    if (typeof type === 'function') type = util.typeName(type);
		    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
		  },

		  typeName: function typeName(type) {
		    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
		    var str = type.toString();
		    var match = str.match(/^\s*function (.+)\(/);
		    return match ? match[1] : str;
		  },

		  error: function error(err, options) {
		    var originalError = null;
		    if (typeof err.message === 'string' && err.message !== '') {
		      if (typeof options === 'string' || (options && options.message)) {
		        originalError = util.copy(err);
		        originalError.message = err.message;
		      }
		    }
		    err.message = err.message || null;

		    if (typeof options === 'string') {
		      err.message = options;
		    } else if (typeof options === 'object' && options !== null) {
		      util.update(err, options);
		      if (options.message)
		        err.message = options.message;
		      if (options.code || options.name)
		        err.code = options.code || options.name;
		      if (options.stack)
		        err.stack = options.stack;
		    }

		    if (typeof Object.defineProperty === 'function') {
		      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
		      Object.defineProperty(err, 'message', {enumerable: true});
		    }

		    err.name = String(options && options.name || err.name || err.code || 'Error');
		    err.time = new Date();

		    if (originalError) err.originalError = originalError;

		    return err;
		  },

		  /**
		   * @api private
		   */
		  inherit: function inherit(klass, features) {
		    var newObject = null;
		    if (features === undefined) {
		      features = klass;
		      klass = Object;
		      newObject = {};
		    } else {
		      var ctor = function ConstructorWrapper() {};
		      ctor.prototype = klass.prototype;
		      newObject = new ctor();
		    }

		    // constructor not supplied, create pass-through ctor
		    if (features.constructor === Object) {
		      features.constructor = function() {
		        if (klass !== Object) {
		          return klass.apply(this, arguments);
		        }
		      };
		    }

		    features.constructor.prototype = newObject;
		    util.update(features.constructor.prototype, features);
		    features.constructor.__super__ = klass;
		    return features.constructor;
		  },

		  /**
		   * @api private
		   */
		  mixin: function mixin() {
		    var klass = arguments[0];
		    for (var i = 1; i < arguments.length; i++) {
		      // jshint forin:false
		      for (var prop in arguments[i].prototype) {
		        var fn = arguments[i].prototype[prop];
		        if (prop !== 'constructor') {
		          klass.prototype[prop] = fn;
		        }
		      }
		    }
		    return klass;
		  },

		  /**
		   * @api private
		   */
		  hideProperties: function hideProperties(obj, props) {
		    if (typeof Object.defineProperty !== 'function') return;

		    util.arrayEach(props, function (key) {
		      Object.defineProperty(obj, key, {
		        enumerable: false, writable: true, configurable: true });
		    });
		  },

		  /**
		   * @api private
		   */
		  property: function property(obj, name, value, enumerable, isValue) {
		    var opts = {
		      configurable: true,
		      enumerable: enumerable !== undefined ? enumerable : true
		    };
		    if (typeof value === 'function' && !isValue) {
		      opts.get = value;
		    }
		    else {
		      opts.value = value; opts.writable = true;
		    }

		    Object.defineProperty(obj, name, opts);
		  },

		  /**
		   * @api private
		   */
		  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
		    var cachedValue = null;

		    // build enumerable attribute for each value with lazy accessor.
		    util.property(obj, name, function() {
		      if (cachedValue === null) {
		        cachedValue = get();
		      }
		      return cachedValue;
		    }, enumerable);
		  },

		  /**
		   * TODO Remove in major version revision
		   * This backfill populates response data without the
		   * top-level payload name.
		   *
		   * @api private
		   */
		  hoistPayloadMember: function hoistPayloadMember(resp) {
		    var req = resp.request;
		    var operationName = req.operation;
		    var operation = req.service.api.operations[operationName];
		    var output = operation.output;
		    if (output.payload && !operation.hasEventOutput) {
		      var payloadMember = output.members[output.payload];
		      var responsePayload = resp.data[output.payload];
		      if (payloadMember.type === 'structure') {
		        util.each(responsePayload, function(key, value) {
		          util.property(resp.data, key, value, false);
		        });
		      }
		    }
		  },

		  /**
		   * Compute SHA-256 checksums of streams
		   *
		   * @api private
		   */
		  computeSha256: function computeSha256(body, done) {
		    if (util.isNode()) {
		      var Stream = util.stream.Stream;
		      var fs = __webpack_require__(6);
		      if (typeof Stream === 'function' && body instanceof Stream) {
		        if (typeof body.path === 'string') { // assume file object
		          var settings = {};
		          if (typeof body.start === 'number') {
		            settings.start = body.start;
		          }
		          if (typeof body.end === 'number') {
		            settings.end = body.end;
		          }
		          body = fs.createReadStream(body.path, settings);
		        } else { // TODO support other stream types
		          return done(new Error('Non-file stream objects are ' +
		                                'not supported with SigV4'));
		        }
		      }
		    }

		    util.crypto.sha256(body, 'hex', function(err, sha) {
		      if (err) done(err);
		      else done(null, sha);
		    });
		  },

		  /**
		   * @api private
		   */
		  isClockSkewed: function isClockSkewed(serverTime) {
		    if (serverTime) {
		      util.property(AWS.config, 'isClockSkewed',
		        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
		      return AWS.config.isClockSkewed;
		    }
		  },

		  applyClockOffset: function applyClockOffset(serverTime) {
		    if (serverTime)
		      AWS.config.systemClockOffset = serverTime - new Date().getTime();
		  },

		  /**
		   * @api private
		   */
		  extractRequestId: function extractRequestId(resp) {
		    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
		                     resp.httpResponse.headers['x-amzn-requestid'];

		    if (!requestId && resp.data && resp.data.ResponseMetadata) {
		      requestId = resp.data.ResponseMetadata.RequestId;
		    }

		    if (requestId) {
		      resp.requestId = requestId;
		    }

		    if (resp.error) {
		      resp.error.requestId = requestId;
		    }
		  },

		  /**
		   * @api private
		   */
		  addPromises: function addPromises(constructors, PromiseDependency) {
		    var deletePromises = false;
		    if (PromiseDependency === undefined && AWS && AWS.config) {
		      PromiseDependency = AWS.config.getPromisesDependency();
		    }
		    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
		      PromiseDependency = Promise;
		    }
		    if (typeof PromiseDependency !== 'function') deletePromises = true;
		    if (!Array.isArray(constructors)) constructors = [constructors];

		    for (var ind = 0; ind < constructors.length; ind++) {
		      var constructor = constructors[ind];
		      if (deletePromises) {
		        if (constructor.deletePromisesFromClass) {
		          constructor.deletePromisesFromClass();
		        }
		      } else if (constructor.addPromisesToClass) {
		        constructor.addPromisesToClass(PromiseDependency);
		      }
		    }
		  },

		  /**
		   * @api private
		   * Return a function that will return a promise whose fate is decided by the
		   * callback behavior of the given method with `methodName`. The method to be
		   * promisified should conform to node.js convention of accepting a callback as
		   * last argument and calling that callback with error as the first argument
		   * and success value on the second argument.
		   */
		  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
		    return function promise() {
		      var self = this;
		      var args = Array.prototype.slice.call(arguments);
		      return new PromiseDependency(function(resolve, reject) {
		        args.push(function(err, data) {
		          if (err) {
		            reject(err);
		          } else {
		            resolve(data);
		          }
		        });
		        self[methodName].apply(self, args);
		      });
		    };
		  },

		  /**
		   * @api private
		   */
		  isDualstackAvailable: function isDualstackAvailable(service) {
		    if (!service) return false;
		    var metadata = __webpack_require__(7);
		    if (typeof service !== 'string') service = service.serviceIdentifier;
		    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
		    return !!metadata[service].dualstackAvailable;
		  },

		  /**
		   * @api private
		   */
		  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
		    if (!retryDelayOptions) retryDelayOptions = {};
		    var customBackoff = retryDelayOptions.customBackoff || null;
		    if (typeof customBackoff === 'function') {
		      return customBackoff(retryCount, err);
		    }
		    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
		    var delay = Math.random() * (Math.pow(2, retryCount) * base);
		    return delay;
		  },

		  /**
		   * @api private
		   */
		  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
		    if (!options) options = {};
		    var http = AWS.HttpClient.getInstance();
		    var httpOptions = options.httpOptions || {};
		    var retryCount = 0;

		    var errCallback = function(err) {
		      var maxRetries = options.maxRetries || 0;
		      if (err && err.code === 'TimeoutError') err.retryable = true;

		      // Call `calculateRetryDelay()` only when relevant, see #3401
		      if (err && err.retryable && retryCount < maxRetries) {
		        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
		        if (delay >= 0) {
		          retryCount++;
		          setTimeout(sendRequest, delay + (err.retryAfter || 0));
		          return;
		        }
		      }
		      cb(err);
		    };

		    var sendRequest = function() {
		      var data = '';
		      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
		        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
		        httpResponse.on('end', function() {
		          var statusCode = httpResponse.statusCode;
		          if (statusCode < 300) {
		            cb(null, data);
		          } else {
		            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
		            var err = util.error(new Error(),
		              {
		                statusCode: statusCode,
		                retryable: statusCode >= 500 || statusCode === 429
		              }
		            );
		            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
		            errCallback(err);
		          }
		        });
		      }, errCallback);
		    };

		    AWS.util.defer(sendRequest);
		  },

		  /**
		   * @api private
		   */
		  uuid: {
		    v4: function uuidV4() {
		      return __webpack_require__(8).v4();
		    }
		  },

		  /**
		   * @api private
		   */
		  convertPayloadToString: function convertPayloadToString(resp) {
		    var req = resp.request;
		    var operation = req.operation;
		    var rules = req.service.api.operations[operation].output || {};
		    if (rules.payload && resp.data[rules.payload]) {
		      resp.data[rules.payload] = resp.data[rules.payload].toString();
		    }
		  },

		  /**
		   * @api private
		   */
		  defer: function defer(callback) {
		    if (typeof process === 'object' && typeof process.nextTick === 'function') {
		      process.nextTick(callback);
		    } else if (typeof setImmediate === 'function') {
		      setImmediate(callback);
		    } else {
		      setTimeout(callback, 0);
		    }
		  },

		  /**
		   * @api private
		   */
		  getRequestPayloadShape: function getRequestPayloadShape(req) {
		    var operations = req.service.api.operations;
		    if (!operations) return undefined;
		    var operation = (operations || {})[req.operation];
		    if (!operation || !operation.input || !operation.input.payload) return undefined;
		    return operation.input.members[operation.input.payload];
		  },

		  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
		    var profiles = {};
		    var profilesFromConfig = {};
		    if (process.env[util.configOptInEnv]) {
		      var profilesFromConfig = iniLoader.loadFrom({
		        isConfig: true,
		        filename: process.env[util.sharedConfigFileEnv]
		      });
		    }
		    var profilesFromCreds= {};
		    try {
		      var profilesFromCreds = iniLoader.loadFrom({
		        filename: filename ||
		          (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
		      });
		    } catch (error) {
		      // if using config, assume it is fully descriptive without a credentials file:
		      if (!process.env[util.configOptInEnv]) throw error;
		    }
		    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
		      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
		    }
		    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
		      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
		    }
		    return profiles;

		    /**
		     * Roughly the semantics of `Object.assign(target, source)`
		     */
		    function objectAssign(target, source) {
		      for (var i = 0, keys = Object.keys(source); i < keys.length; i++) {
		        target[keys[i]] = source[keys[i]];
		      }
		      return target;
		    }
		  },

		  /**
		   * @api private
		   */
		  ARN: {
		    validate: function validateARN(str) {
		      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
		    },
		    parse: function parseARN(arn) {
		      var matched = arn.split(':');
		      return {
		        partition: matched[1],
		        service: matched[2],
		        region: matched[3],
		        accountId: matched[4],
		        resource: matched.slice(5).join(':')
		      };
		    },
		    build: function buildARN(arnObject) {
		      if (
		        arnObject.service === undefined ||
		        arnObject.region === undefined ||
		        arnObject.accountId === undefined ||
		        arnObject.resource === undefined
		      ) throw util.error(new Error('Input ARN object is invalid'));
		      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
		        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
		    }
		  },

		  /**
		   * @api private
		   */
		  defaultProfile: 'default',

		  /**
		   * @api private
		   */
		  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

		  /**
		   * @api private
		   */
		  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

		  /**
		   * @api private
		   */
		  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

		  /**
		   * @api private
		   */
		  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
		};

		/**
		 * @api private
		 */
		module.exports = util;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(4).setImmediate))

	/***/ }),
	/* 3 */
	/***/ (function(module, exports) {

		// shim for using process in browser
		var process = module.exports = {};

		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.

		var cachedSetTimeout;
		var cachedClearTimeout;

		function defaultSetTimout() {
		    throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
		    throw new Error('clearTimeout has not been defined');
		}
		(function () {
		    try {
		        if (typeof setTimeout === 'function') {
		            cachedSetTimeout = setTimeout;
		        } else {
		            cachedSetTimeout = defaultSetTimout;
		        }
		    } catch (e) {
		        cachedSetTimeout = defaultSetTimout;
		    }
		    try {
		        if (typeof clearTimeout === 'function') {
		            cachedClearTimeout = clearTimeout;
		        } else {
		            cachedClearTimeout = defaultClearTimeout;
		        }
		    } catch (e) {
		        cachedClearTimeout = defaultClearTimeout;
		    }
		} ())
		function runTimeout(fun) {
		    if (cachedSetTimeout === setTimeout) {
		        //normal enviroments in sane situations
		        return setTimeout(fun, 0);
		    }
		    // if setTimeout wasn't available but was latter defined
		    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		        cachedSetTimeout = setTimeout;
		        return setTimeout(fun, 0);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedSetTimeout(fun, 0);
		    } catch(e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		            return cachedSetTimeout.call(null, fun, 0);
		        } catch(e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		            return cachedSetTimeout.call(this, fun, 0);
		        }
		    }


		}
		function runClearTimeout(marker) {
		    if (cachedClearTimeout === clearTimeout) {
		        //normal enviroments in sane situations
		        return clearTimeout(marker);
		    }
		    // if clearTimeout wasn't available but was latter defined
		    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		        cachedClearTimeout = clearTimeout;
		        return clearTimeout(marker);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedClearTimeout(marker);
		    } catch (e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		            return cachedClearTimeout.call(null, marker);
		        } catch (e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		            return cachedClearTimeout.call(this, marker);
		        }
		    }



		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}

		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = runTimeout(cleanUpNextTick);
		    draining = true;

		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    runClearTimeout(timeout);
		}

		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        runTimeout(drainQueue);
		    }
		};

		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};

		function noop() {}

		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;

		process.listeners = function (name) { return [] }

		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};

		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };


	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
		            (typeof self !== "undefined" && self) ||
		            window;
		var apply = Function.prototype.apply;

		// DOM APIs, for completeness

		exports.setTimeout = function() {
		  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
		};
		exports.setInterval = function() {
		  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
		};
		exports.clearTimeout =
		exports.clearInterval = function(timeout) {
		  if (timeout) {
		    timeout.close();
		  }
		};

		function Timeout(id, clearFn) {
		  this._id = id;
		  this._clearFn = clearFn;
		}
		Timeout.prototype.unref = Timeout.prototype.ref = function() {};
		Timeout.prototype.close = function() {
		  this._clearFn.call(scope, this._id);
		};

		// Does not start the time, just sets up the members needed.
		exports.enroll = function(item, msecs) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = msecs;
		};

		exports.unenroll = function(item) {
		  clearTimeout(item._idleTimeoutId);
		  item._idleTimeout = -1;
		};

		exports._unrefActive = exports.active = function(item) {
		  clearTimeout(item._idleTimeoutId);

		  var msecs = item._idleTimeout;
		  if (msecs >= 0) {
		    item._idleTimeoutId = setTimeout(function onTimeout() {
		      if (item._onTimeout)
		        item._onTimeout();
		    }, msecs);
		  }
		};

		// setimmediate attaches itself to the global object
		__webpack_require__(5);
		// On some exotic environments, it's not clear which object `setimmediate` was
		// able to install onto.  Search each possibility in the same order as the
		// `setimmediate` library.
		exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
		                       (typeof global !== "undefined" && global.setImmediate) ||
		                       (this && this.setImmediate);
		exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
		                         (typeof global !== "undefined" && global.clearImmediate) ||
		                         (this && this.clearImmediate);

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ }),
	/* 5 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
		    "use strict";

		    if (global.setImmediate) {
		        return;
		    }

		    var nextHandle = 1; // Spec says greater than zero
		    var tasksByHandle = {};
		    var currentlyRunningATask = false;
		    var doc = global.document;
		    var registerImmediate;

		    function setImmediate(callback) {
		      // Callback can either be a function or a string
		      if (typeof callback !== "function") {
		        callback = new Function("" + callback);
		      }
		      // Copy function arguments
		      var args = new Array(arguments.length - 1);
		      for (var i = 0; i < args.length; i++) {
		          args[i] = arguments[i + 1];
		      }
		      // Store and register the task
		      var task = { callback: callback, args: args };
		      tasksByHandle[nextHandle] = task;
		      registerImmediate(nextHandle);
		      return nextHandle++;
		    }

		    function clearImmediate(handle) {
		        delete tasksByHandle[handle];
		    }

		    function run(task) {
		        var callback = task.callback;
		        var args = task.args;
		        switch (args.length) {
		        case 0:
		            callback();
		            break;
		        case 1:
		            callback(args[0]);
		            break;
		        case 2:
		            callback(args[0], args[1]);
		            break;
		        case 3:
		            callback(args[0], args[1], args[2]);
		            break;
		        default:
		            callback.apply(undefined, args);
		            break;
		        }
		    }

		    function runIfPresent(handle) {
		        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
		        // So if we're currently running a task, we'll need to delay this invocation.
		        if (currentlyRunningATask) {
		            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
		            // "too much recursion" error.
		            setTimeout(runIfPresent, 0, handle);
		        } else {
		            var task = tasksByHandle[handle];
		            if (task) {
		                currentlyRunningATask = true;
		                try {
		                    run(task);
		                } finally {
		                    clearImmediate(handle);
		                    currentlyRunningATask = false;
		                }
		            }
		        }
		    }

		    function installNextTickImplementation() {
		        registerImmediate = function(handle) {
		            process.nextTick(function () { runIfPresent(handle); });
		        };
		    }

		    function canUsePostMessage() {
		        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
		        // where `global.postMessage` means something completely different and can't be used for this purpose.
		        if (global.postMessage && !global.importScripts) {
		            var postMessageIsAsynchronous = true;
		            var oldOnMessage = global.onmessage;
		            global.onmessage = function() {
		                postMessageIsAsynchronous = false;
		            };
		            global.postMessage("", "*");
		            global.onmessage = oldOnMessage;
		            return postMessageIsAsynchronous;
		        }
		    }

		    function installPostMessageImplementation() {
		        // Installs an event handler on `global` for the `message` event: see
		        // * https://developer.mozilla.org/en/DOM/window.postMessage
		        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

		        var messagePrefix = "setImmediate$" + Math.random() + "$";
		        var onGlobalMessage = function(event) {
		            if (event.source === global &&
		                typeof event.data === "string" &&
		                event.data.indexOf(messagePrefix) === 0) {
		                runIfPresent(+event.data.slice(messagePrefix.length));
		            }
		        };

		        if (global.addEventListener) {
		            global.addEventListener("message", onGlobalMessage, false);
		        } else {
		            global.attachEvent("onmessage", onGlobalMessage);
		        }

		        registerImmediate = function(handle) {
		            global.postMessage(messagePrefix + handle, "*");
		        };
		    }

		    function installMessageChannelImplementation() {
		        var channel = new MessageChannel();
		        channel.port1.onmessage = function(event) {
		            var handle = event.data;
		            runIfPresent(handle);
		        };

		        registerImmediate = function(handle) {
		            channel.port2.postMessage(handle);
		        };
		    }

		    function installReadyStateChangeImplementation() {
		        var html = doc.documentElement;
		        registerImmediate = function(handle) {
		            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
		            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
		            var script = doc.createElement("script");
		            script.onreadystatechange = function () {
		                runIfPresent(handle);
		                script.onreadystatechange = null;
		                html.removeChild(script);
		                script = null;
		            };
		            html.appendChild(script);
		        };
		    }

		    function installSetTimeoutImplementation() {
		        registerImmediate = function(handle) {
		            setTimeout(runIfPresent, 0, handle);
		        };
		    }

		    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
		    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
		    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

		    // Don't get fooled by e.g. browserify environments.
		    if ({}.toString.call(global.process) === "[object process]") {
		        // For Node.js before 0.9
		        installNextTickImplementation();

		    } else if (canUsePostMessage()) {
		        // For non-IE10 modern browsers
		        installPostMessageImplementation();

		    } else if (global.MessageChannel) {
		        // For web workers, where supported
		        installMessageChannelImplementation();

		    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
		        // For IE 6–8
		        installReadyStateChangeImplementation();

		    } else {
		        // For older browsers
		        installSetTimeoutImplementation();
		    }

		    attachTo.setImmediate = setImmediate;
		    attachTo.clearImmediate = clearImmediate;
		}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3)))

	/***/ }),
	/* 6 */
	/***/ (function(module, exports) {

		/* (ignored) */

	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {

		module.exports = {"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory","versions":["2016-05-10*"]},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*","2017-03-25*","2017-10-30*","2018-06-18*","2018-11-05*","2019-03-26*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild","cors":true},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM","cors":true},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"s3control":{"name":"S3Control","dualstackAvailable":true,"xmlNoDefaultLists":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay","cors":true},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService","cors":true},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena","cors":true},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2","cors":true},"glue":{"name":"Glue"},"mobile":{"name":"Mobile"},"pricing":{"name":"Pricing","cors":true},"costexplorer":{"prefix":"ce","name":"CostExplorer","cors":true},"mediaconvert":{"name":"MediaConvert"},"medialive":{"name":"MediaLive"},"mediapackage":{"name":"MediaPackage"},"mediastore":{"name":"MediaStore"},"mediastoredata":{"prefix":"mediastore-data","name":"MediaStoreData","cors":true},"appsync":{"name":"AppSync"},"guardduty":{"name":"GuardDuty"},"mq":{"name":"MQ"},"comprehend":{"name":"Comprehend","cors":true},"iotjobsdataplane":{"prefix":"iot-jobs-data","name":"IoTJobsDataPlane"},"kinesisvideoarchivedmedia":{"prefix":"kinesis-video-archived-media","name":"KinesisVideoArchivedMedia","cors":true},"kinesisvideomedia":{"prefix":"kinesis-video-media","name":"KinesisVideoMedia","cors":true},"kinesisvideo":{"name":"KinesisVideo","cors":true},"sagemakerruntime":{"prefix":"runtime.sagemaker","name":"SageMakerRuntime"},"sagemaker":{"name":"SageMaker"},"translate":{"name":"Translate","cors":true},"resourcegroups":{"prefix":"resource-groups","name":"ResourceGroups","cors":true},"alexaforbusiness":{"name":"AlexaForBusiness"},"cloud9":{"name":"Cloud9"},"serverlessapplicationrepository":{"prefix":"serverlessrepo","name":"ServerlessApplicationRepository"},"servicediscovery":{"name":"ServiceDiscovery"},"workmail":{"name":"WorkMail"},"autoscalingplans":{"prefix":"autoscaling-plans","name":"AutoScalingPlans"},"transcribeservice":{"prefix":"transcribe","name":"TranscribeService"},"connect":{"name":"Connect","cors":true},"acmpca":{"prefix":"acm-pca","name":"ACMPCA"},"fms":{"name":"FMS"},"secretsmanager":{"name":"SecretsManager","cors":true},"iotanalytics":{"name":"IoTAnalytics","cors":true},"iot1clickdevicesservice":{"prefix":"iot1click-devices","name":"IoT1ClickDevicesService"},"iot1clickprojects":{"prefix":"iot1click-projects","name":"IoT1ClickProjects"},"pi":{"name":"PI"},"neptune":{"name":"Neptune"},"mediatailor":{"name":"MediaTailor"},"eks":{"name":"EKS"},"macie":{"name":"Macie"},"dlm":{"name":"DLM"},"signer":{"name":"Signer"},"chime":{"name":"Chime"},"pinpointemail":{"prefix":"pinpoint-email","name":"PinpointEmail"},"ram":{"name":"RAM"},"route53resolver":{"name":"Route53Resolver"},"pinpointsmsvoice":{"prefix":"sms-voice","name":"PinpointSMSVoice"},"quicksight":{"name":"QuickSight"},"rdsdataservice":{"prefix":"rds-data","name":"RDSDataService"},"amplify":{"name":"Amplify"},"datasync":{"name":"DataSync"},"robomaker":{"name":"RoboMaker"},"transfer":{"name":"Transfer"},"globalaccelerator":{"name":"GlobalAccelerator"},"comprehendmedical":{"name":"ComprehendMedical","cors":true},"kinesisanalyticsv2":{"name":"KinesisAnalyticsV2"},"mediaconnect":{"name":"MediaConnect"},"fsx":{"name":"FSx"},"securityhub":{"name":"SecurityHub"},"appmesh":{"name":"AppMesh","versions":["2018-10-01*"]},"licensemanager":{"prefix":"license-manager","name":"LicenseManager"},"kafka":{"name":"Kafka"},"apigatewaymanagementapi":{"name":"ApiGatewayManagementApi"},"apigatewayv2":{"name":"ApiGatewayV2"},"docdb":{"name":"DocDB"},"backup":{"name":"Backup"},"worklink":{"name":"WorkLink"},"textract":{"name":"Textract"},"managedblockchain":{"name":"ManagedBlockchain"},"mediapackagevod":{"prefix":"mediapackage-vod","name":"MediaPackageVod"},"groundstation":{"name":"GroundStation"},"iotthingsgraph":{"name":"IoTThingsGraph"},"iotevents":{"name":"IoTEvents"},"ioteventsdata":{"prefix":"iotevents-data","name":"IoTEventsData"},"personalize":{"name":"Personalize","cors":true},"personalizeevents":{"prefix":"personalize-events","name":"PersonalizeEvents","cors":true},"personalizeruntime":{"prefix":"personalize-runtime","name":"PersonalizeRuntime","cors":true},"applicationinsights":{"prefix":"application-insights","name":"ApplicationInsights"},"servicequotas":{"prefix":"service-quotas","name":"ServiceQuotas"},"ec2instanceconnect":{"prefix":"ec2-instance-connect","name":"EC2InstanceConnect"},"eventbridge":{"name":"EventBridge"},"lakeformation":{"name":"LakeFormation"},"forecastservice":{"prefix":"forecast","name":"ForecastService","cors":true},"forecastqueryservice":{"prefix":"forecastquery","name":"ForecastQueryService","cors":true},"qldb":{"name":"QLDB"},"qldbsession":{"prefix":"qldb-session","name":"QLDBSession"},"workmailmessageflow":{"name":"WorkMailMessageFlow"},"codestarnotifications":{"prefix":"codestar-notifications","name":"CodeStarNotifications"},"savingsplans":{"name":"SavingsPlans"},"sso":{"name":"SSO"},"ssooidc":{"prefix":"sso-oidc","name":"SSOOIDC"},"marketplacecatalog":{"prefix":"marketplace-catalog","name":"MarketplaceCatalog","cors":true},"dataexchange":{"name":"DataExchange"},"sesv2":{"name":"SESV2"},"migrationhubconfig":{"prefix":"migrationhub-config","name":"MigrationHubConfig"},"connectparticipant":{"name":"ConnectParticipant"},"appconfig":{"name":"AppConfig"},"iotsecuretunneling":{"name":"IoTSecureTunneling"},"wafv2":{"name":"WAFV2"},"elasticinference":{"prefix":"elastic-inference","name":"ElasticInference"},"imagebuilder":{"name":"Imagebuilder"},"schemas":{"name":"Schemas"},"accessanalyzer":{"name":"AccessAnalyzer"},"codegurureviewer":{"prefix":"codeguru-reviewer","name":"CodeGuruReviewer"},"codeguruprofiler":{"name":"CodeGuruProfiler"},"computeoptimizer":{"prefix":"compute-optimizer","name":"ComputeOptimizer"},"frauddetector":{"name":"FraudDetector"},"kendra":{"name":"Kendra"},"networkmanager":{"name":"NetworkManager"},"outposts":{"name":"Outposts"},"augmentedairuntime":{"prefix":"sagemaker-a2i-runtime","name":"AugmentedAIRuntime"},"ebs":{"name":"EBS"},"kinesisvideosignalingchannels":{"prefix":"kinesis-video-signaling","name":"KinesisVideoSignalingChannels","cors":true},"detective":{"name":"Detective"},"codestarconnections":{"prefix":"codestar-connections","name":"CodeStarconnections"},"synthetics":{"name":"Synthetics"},"iotsitewise":{"name":"IoTSiteWise"},"macie2":{"name":"Macie2"},"codeartifact":{"name":"CodeArtifact"},"honeycode":{"name":"Honeycode"},"ivs":{"name":"IVS"},"braket":{"name":"Braket"},"identitystore":{"name":"IdentityStore"},"appflow":{"name":"Appflow"},"redshiftdata":{"prefix":"redshift-data","name":"RedshiftData"},"ssoadmin":{"prefix":"sso-admin","name":"SSOAdmin"},"timestreamquery":{"prefix":"timestream-query","name":"TimestreamQuery"},"timestreamwrite":{"prefix":"timestream-write","name":"TimestreamWrite"},"s3outposts":{"name":"S3Outposts"},"databrew":{"name":"DataBrew"},"servicecatalogappregistry":{"prefix":"servicecatalog-appregistry","name":"ServiceCatalogAppRegistry"},"networkfirewall":{"prefix":"network-firewall","name":"NetworkFirewall"},"mwaa":{"name":"MWAA"},"amplifybackend":{"name":"AmplifyBackend"},"appintegrations":{"name":"AppIntegrations"},"connectcontactlens":{"prefix":"connect-contact-lens","name":"ConnectContactLens"},"devopsguru":{"prefix":"devops-guru","name":"DevOpsGuru"},"ecrpublic":{"prefix":"ecr-public","name":"ECRPUBLIC"},"lookoutvision":{"name":"LookoutVision"},"sagemakerfeaturestoreruntime":{"prefix":"sagemaker-featurestore-runtime","name":"SageMakerFeatureStoreRuntime"},"customerprofiles":{"prefix":"customer-profiles","name":"CustomerProfiles"},"auditmanager":{"name":"AuditManager"},"emrcontainers":{"prefix":"emr-containers","name":"EMRcontainers"},"healthlake":{"name":"HealthLake"},"sagemakeredge":{"prefix":"sagemaker-edge","name":"SagemakerEdge"},"amp":{"name":"Amp"},"greengrassv2":{"name":"GreengrassV2"},"iotdeviceadvisor":{"name":"IotDeviceAdvisor"},"iotfleethub":{"name":"IoTFleetHub"},"iotwireless":{"name":"IoTWireless"},"location":{"name":"Location","cors":true},"wellarchitected":{"name":"WellArchitected"},"lexmodelsv2":{"prefix":"models.lex.v2","name":"LexModelsV2"},"lexruntimev2":{"prefix":"runtime.lex.v2","name":"LexRuntimeV2","cors":true},"fis":{"name":"Fis"},"lookoutmetrics":{"name":"LookoutMetrics"},"mgn":{"name":"Mgn"},"lookoutequipment":{"name":"LookoutEquipment"},"nimble":{"name":"Nimble"},"finspace":{"name":"Finspace"},"finspacedata":{"prefix":"finspace-data","name":"Finspacedata"},"ssmcontacts":{"prefix":"ssm-contacts","name":"SSMContacts"},"ssmincidents":{"prefix":"ssm-incidents","name":"SSMIncidents"},"applicationcostprofiler":{"name":"ApplicationCostProfiler"},"apprunner":{"name":"AppRunner"},"proton":{"name":"Proton"},"route53recoverycluster":{"prefix":"route53-recovery-cluster","name":"Route53RecoveryCluster"},"route53recoverycontrolconfig":{"prefix":"route53-recovery-control-config","name":"Route53RecoveryControlConfig"},"route53recoveryreadiness":{"prefix":"route53-recovery-readiness","name":"Route53RecoveryReadiness"},"chimesdkidentity":{"prefix":"chime-sdk-identity","name":"ChimeSDKIdentity"},"chimesdkmessaging":{"prefix":"chime-sdk-messaging","name":"ChimeSDKMessaging"},"snowdevicemanagement":{"prefix":"snow-device-management","name":"SnowDeviceManagement"},"memorydb":{"name":"MemoryDB"},"opensearch":{"name":"OpenSearch"},"kafkaconnect":{"name":"KafkaConnect"},"voiceid":{"prefix":"voice-id","name":"VoiceID"},"wisdom":{"name":"Wisdom"},"account":{"name":"Account"},"cloudcontrol":{"name":"CloudControl"},"grafana":{"name":"Grafana"},"panorama":{"name":"Panorama"},"chimesdkmeetings":{"prefix":"chime-sdk-meetings","name":"ChimeSDKMeetings"},"resiliencehub":{"name":"Resiliencehub"},"migrationhubstrategy":{"name":"MigrationHubStrategy"},"appconfigdata":{"name":"AppConfigData"},"drs":{"name":"Drs"},"migrationhubrefactorspaces":{"prefix":"migration-hub-refactor-spaces","name":"MigrationHubRefactorSpaces"},"evidently":{"name":"Evidently"},"inspector2":{"name":"Inspector2"},"rbin":{"name":"Rbin"},"rum":{"name":"RUM"},"backupgateway":{"prefix":"backup-gateway","name":"BackupGateway"},"iottwinmaker":{"name":"IoTTwinMaker"},"workspacesweb":{"prefix":"workspaces-web","name":"WorkSpacesWeb"},"amplifyuibuilder":{"name":"AmplifyUIBuilder"},"keyspaces":{"name":"Keyspaces"},"billingconductor":{"name":"Billingconductor"},"gamesparks":{"name":"GameSparks"},"pinpointsmsvoicev2":{"prefix":"pinpoint-sms-voice-v2","name":"PinpointSMSVoiceV2"},"ivschat":{"name":"Ivschat"},"chimesdkmediapipelines":{"prefix":"chime-sdk-media-pipelines","name":"ChimeSDKMediaPipelines"},"emrserverless":{"prefix":"emr-serverless","name":"EMRServerless"},"m2":{"name":"M2"},"connectcampaigns":{"name":"ConnectCampaigns"},"redshiftserverless":{"prefix":"redshift-serverless","name":"RedshiftServerless"},"rolesanywhere":{"name":"RolesAnywhere"},"licensemanagerusersubscriptions":{"prefix":"license-manager-user-subscriptions","name":"LicenseManagerUserSubscriptions"},"backupstorage":{"name":"BackupStorage"},"privatenetworks":{"name":"PrivateNetworks"},"supportapp":{"prefix":"support-app","name":"SupportApp"},"controltower":{"name":"ControlTower"},"iotfleetwise":{"name":"IoTFleetWise"},"migrationhuborchestrator":{"name":"MigrationHubOrchestrator"},"connectcases":{"name":"ConnectCases"},"resourceexplorer2":{"prefix":"resource-explorer-2","name":"ResourceExplorer2"},"scheduler":{"name":"Scheduler"},"chimesdkvoice":{"prefix":"chime-sdk-voice","name":"ChimeSDKVoice"},"iotroborunner":{"prefix":"iot-roborunner","name":"IoTRoboRunner"},"ssmsap":{"prefix":"ssm-sap","name":"SsmSap"}}

	/***/ }),
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "v1", {
		  enumerable: true,
		  get: function () {
		    return _v.default;
		  }
		});
		Object.defineProperty(exports, "v3", {
		  enumerable: true,
		  get: function () {
		    return _v2.default;
		  }
		});
		Object.defineProperty(exports, "v4", {
		  enumerable: true,
		  get: function () {
		    return _v3.default;
		  }
		});
		Object.defineProperty(exports, "v5", {
		  enumerable: true,
		  get: function () {
		    return _v4.default;
		  }
		});

		var _v = _interopRequireDefault(__webpack_require__(9));

		var _v2 = _interopRequireDefault(__webpack_require__(12));

		var _v3 = _interopRequireDefault(__webpack_require__(15));

		var _v4 = _interopRequireDefault(__webpack_require__(16));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		var _rng = _interopRequireDefault(__webpack_require__(10));

		var _bytesToUuid = _interopRequireDefault(__webpack_require__(11));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		// **`v1()` - Generate time-based UUID**
		//
		// Inspired by https://github.com/LiosK/UUID.js
		// and http://docs.python.org/library/uuid.html
		var _nodeId;

		var _clockseq; // Previous uuid creation time


		var _lastMSecs = 0;
		var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

		function v1(options, buf, offset) {
		  var i = buf && offset || 0;
		  var b = buf || [];
		  options = options || {};
		  var node = options.node || _nodeId;
		  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
		  // specified.  We do this lazily to minimize issues related to insufficient
		  // system entropy.  See #189

		  if (node == null || clockseq == null) {
		    var seedBytes = options.random || (options.rng || _rng.default)();

		    if (node == null) {
		      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
		      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
		    }

		    if (clockseq == null) {
		      // Per 4.2.2, randomize (14 bit) clockseq
		      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
		    }
		  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
		  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
		  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
		  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


		  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
		  // cycle to simulate higher resolution clock

		  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

		  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

		  if (dt < 0 && options.clockseq === undefined) {
		    clockseq = clockseq + 1 & 0x3fff;
		  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
		  // time interval


		  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
		    nsecs = 0;
		  } // Per 4.2.1.2 Throw error if too many uuids are requested


		  if (nsecs >= 10000) {
		    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
		  }

		  _lastMSecs = msecs;
		  _lastNSecs = nsecs;
		  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

		  msecs += 12219292800000; // `time_low`

		  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
		  b[i++] = tl >>> 24 & 0xff;
		  b[i++] = tl >>> 16 & 0xff;
		  b[i++] = tl >>> 8 & 0xff;
		  b[i++] = tl & 0xff; // `time_mid`

		  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
		  b[i++] = tmh >>> 8 & 0xff;
		  b[i++] = tmh & 0xff; // `time_high_and_version`

		  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

		  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

		  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

		  b[i++] = clockseq & 0xff; // `node`

		  for (var n = 0; n < 6; ++n) {
		    b[i + n] = node[n];
		  }

		  return buf ? buf : (0, _bytesToUuid.default)(b);
		}

		var _default = v1;
		exports.default = _default;

	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = rng;
		// Unique ID creation requires a high quality random # generator. In the browser we therefore
		// require the crypto API and do not support built-in fallback to lower quality random number
		// generators (like Math.random()).
		// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
		// find the complete implementation of crypto (msCrypto) on IE11.
		var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
		var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

		function rng() {
		  if (!getRandomValues) {
		    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
		  }

		  return getRandomValues(rnds8);
		}

	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		/**
		 * Convert array of 16 byte values to UUID string format of the form:
		 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
		 */
		var byteToHex = [];

		for (var i = 0; i < 256; ++i) {
		  byteToHex[i] = (i + 0x100).toString(16).substr(1);
		}

		function bytesToUuid(buf, offset) {
		  var i = offset || 0;
		  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

		  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
		}

		var _default = bytesToUuid;
		exports.default = _default;

	/***/ }),
	/* 12 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		var _v = _interopRequireDefault(__webpack_require__(13));

		var _md = _interopRequireDefault(__webpack_require__(14));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const v3 = (0, _v.default)('v3', 0x30, _md.default);
		var _default = v3;
		exports.default = _default;

	/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = _default;
		exports.URL = exports.DNS = void 0;

		var _bytesToUuid = _interopRequireDefault(__webpack_require__(11));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function uuidToBytes(uuid) {
		  // Note: We assume we're being passed a valid uuid string
		  var bytes = [];
		  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
		    bytes.push(parseInt(hex, 16));
		  });
		  return bytes;
		}

		function stringToBytes(str) {
		  str = unescape(encodeURIComponent(str)); // UTF8 escape

		  var bytes = new Array(str.length);

		  for (var i = 0; i < str.length; i++) {
		    bytes[i] = str.charCodeAt(i);
		  }

		  return bytes;
		}

		const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
		exports.DNS = DNS;
		const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
		exports.URL = URL;

		function _default(name, version, hashfunc) {
		  var generateUUID = function (value, namespace, buf, offset) {
		    var off = buf && offset || 0;
		    if (typeof value == 'string') value = stringToBytes(value);
		    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
		    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
		    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

		    var bytes = hashfunc(namespace.concat(value));
		    bytes[6] = bytes[6] & 0x0f | version;
		    bytes[8] = bytes[8] & 0x3f | 0x80;

		    if (buf) {
		      for (var idx = 0; idx < 16; ++idx) {
		        buf[off + idx] = bytes[idx];
		      }
		    }

		    return buf || (0, _bytesToUuid.default)(bytes);
		  }; // Function#name is not settable on some platforms (#270)


		  try {
		    generateUUID.name = name;
		  } catch (err) {} // For CommonJS default export support


		  generateUUID.DNS = DNS;
		  generateUUID.URL = URL;
		  return generateUUID;
		}

	/***/ }),
	/* 14 */
	/***/ (function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		/*
		 * Browser-compatible JavaScript MD5
		 *
		 * Modification of JavaScript MD5
		 * https://github.com/blueimp/JavaScript-MD5
		 *
		 * Copyright 2011, Sebastian Tschan
		 * https://blueimp.net
		 *
		 * Licensed under the MIT license:
		 * https://opensource.org/licenses/MIT
		 *
		 * Based on
		 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
		 * Digest Algorithm, as defined in RFC 1321.
		 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
		 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
		 * Distributed under the BSD License
		 * See http://pajhome.org.uk/crypt/md5 for more info.
		 */
		function md5(bytes) {
		  if (typeof bytes == 'string') {
		    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

		    bytes = new Array(msg.length);

		    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
		  }

		  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
		}
		/*
		 * Convert an array of little-endian words to an array of bytes
		 */


		function md5ToHexEncodedArray(input) {
		  var i;
		  var x;
		  var output = [];
		  var length32 = input.length * 32;
		  var hexTab = '0123456789abcdef';
		  var hex;

		  for (i = 0; i < length32; i += 8) {
		    x = input[i >> 5] >>> i % 32 & 0xff;
		    hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
		    output.push(hex);
		  }

		  return output;
		}
		/*
		 * Calculate the MD5 of an array of little-endian words, and a bit length.
		 */


		function wordsToMd5(x, len) {
		  /* append padding */
		  x[len >> 5] |= 0x80 << len % 32;
		  x[(len + 64 >>> 9 << 4) + 14] = len;
		  var i;
		  var olda;
		  var oldb;
		  var oldc;
		  var oldd;
		  var a = 1732584193;
		  var b = -271733879;
		  var c = -1732584194;
		  var d = 271733878;

		  for (i = 0; i < x.length; i += 16) {
		    olda = a;
		    oldb = b;
		    oldc = c;
		    oldd = d;
		    a = md5ff(a, b, c, d, x[i], 7, -680876936);
		    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
		    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
		    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
		    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
		    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
		    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
		    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
		    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
		    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
		    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
		    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
		    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
		    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
		    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
		    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
		    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
		    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
		    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
		    b = md5gg(b, c, d, a, x[i], 20, -373897302);
		    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
		    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
		    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
		    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
		    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
		    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
		    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
		    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
		    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
		    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
		    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
		    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
		    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
		    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
		    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
		    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
		    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
		    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
		    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
		    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
		    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
		    d = md5hh(d, a, b, c, x[i], 11, -358537222);
		    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
		    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
		    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
		    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
		    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
		    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
		    a = md5ii(a, b, c, d, x[i], 6, -198630844);
		    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
		    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
		    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
		    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
		    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
		    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
		    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
		    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
		    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
		    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
		    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
		    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
		    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
		    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
		    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
		    a = safeAdd(a, olda);
		    b = safeAdd(b, oldb);
		    c = safeAdd(c, oldc);
		    d = safeAdd(d, oldd);
		  }

		  return [a, b, c, d];
		}
		/*
		 * Convert an array bytes to an array of little-endian words
		 * Characters >255 have their high-byte silently ignored.
		 */


		function bytesToWords(input) {
		  var i;
		  var output = [];
		  output[(input.length >> 2) - 1] = undefined;

		  for (i = 0; i < output.length; i += 1) {
		    output[i] = 0;
		  }

		  var length8 = input.length * 8;

		  for (i = 0; i < length8; i += 8) {
		    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
		  }

		  return output;
		}
		/*
		 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
		 * to work around bugs in some JS interpreters.
		 */


		function safeAdd(x, y) {
		  var lsw = (x & 0xffff) + (y & 0xffff);
		  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		  return msw << 16 | lsw & 0xffff;
		}
		/*
		 * Bitwise rotate a 32-bit number to the left.
		 */


		function bitRotateLeft(num, cnt) {
		  return num << cnt | num >>> 32 - cnt;
		}
		/*
		 * These functions implement the four basic operations the algorithm uses.
		 */


		function md5cmn(q, a, b, x, s, t) {
		  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
		}

		function md5ff(a, b, c, d, x, s, t) {
		  return md5cmn(b & c | ~b & d, a, b, x, s, t);
		}

		function md5gg(a, b, c, d, x, s, t) {
		  return md5cmn(b & d | c & ~d, a, b, x, s, t);
		}

		function md5hh(a, b, c, d, x, s, t) {
		  return md5cmn(b ^ c ^ d, a, b, x, s, t);
		}

		function md5ii(a, b, c, d, x, s, t) {
		  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
		}

		var _default = md5;
		exports.default = _default;

	/***/ }),
	/* 15 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		var _rng = _interopRequireDefault(__webpack_require__(10));

		var _bytesToUuid = _interopRequireDefault(__webpack_require__(11));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function v4(options, buf, offset) {
		  var i = buf && offset || 0;

		  if (typeof options == 'string') {
		    buf = options === 'binary' ? new Array(16) : null;
		    options = null;
		  }

		  options = options || {};

		  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


		  rnds[6] = rnds[6] & 0x0f | 0x40;
		  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

		  if (buf) {
		    for (var ii = 0; ii < 16; ++ii) {
		      buf[i + ii] = rnds[ii];
		    }
		  }

		  return buf || (0, _bytesToUuid.default)(rnds);
		}

		var _default = v4;
		exports.default = _default;

	/***/ }),
	/* 16 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		var _v = _interopRequireDefault(__webpack_require__(13));

		var _sha = _interopRequireDefault(__webpack_require__(17));

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		const v5 = (0, _v.default)('v5', 0x50, _sha.default);
		var _default = v5;
		exports.default = _default;

	/***/ }),
	/* 17 */
	/***/ (function(module, exports) {

		"use strict";

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = void 0;

		// Adapted from Chris Veness' SHA1 code at
		// http://www.movable-type.co.uk/scripts/sha1.html
		function f(s, x, y, z) {
		  switch (s) {
		    case 0:
		      return x & y ^ ~x & z;

		    case 1:
		      return x ^ y ^ z;

		    case 2:
		      return x & y ^ x & z ^ y & z;

		    case 3:
		      return x ^ y ^ z;
		  }
		}

		function ROTL(x, n) {
		  return x << n | x >>> 32 - n;
		}

		function sha1(bytes) {
		  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
		  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

		  if (typeof bytes == 'string') {
		    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

		    bytes = new Array(msg.length);

		    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
		  }

		  bytes.push(0x80);
		  var l = bytes.length / 4 + 2;
		  var N = Math.ceil(l / 16);
		  var M = new Array(N);

		  for (var i = 0; i < N; i++) {
		    M[i] = new Array(16);

		    for (var j = 0; j < 16; j++) {
		      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
		    }
		  }

		  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
		  M[N - 1][14] = Math.floor(M[N - 1][14]);
		  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

		  for (var i = 0; i < N; i++) {
		    var W = new Array(80);

		    for (var t = 0; t < 16; t++) W[t] = M[i][t];

		    for (var t = 16; t < 80; t++) {
		      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
		    }

		    var a = H[0];
		    var b = H[1];
		    var c = H[2];
		    var d = H[3];
		    var e = H[4];

		    for (var t = 0; t < 80; t++) {
		      var s = Math.floor(t / 20);
		      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
		      e = d;
		      d = c;
		      c = ROTL(b, 30) >>> 0;
		      b = a;
		      a = T;
		    }

		    H[0] = H[0] + a >>> 0;
		    H[1] = H[1] + b >>> 0;
		    H[2] = H[2] + c >>> 0;
		    H[3] = H[3] + d >>> 0;
		    H[4] = H[4] + e >>> 0;
		  }

		  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
		}

		var _default = sha1;
		exports.default = _default;

	/***/ }),
	/* 18 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var JsonBuilder = __webpack_require__(19);
		var JsonParser = __webpack_require__(20);
		var populateHostPrefix = __webpack_require__(21).populateHostPrefix;

		function buildRequest(req) {
		  var httpRequest = req.httpRequest;
		  var api = req.service.api;
		  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
		  var version = api.jsonVersion || '1.0';
		  var input = api.operations[req.operation].input;
		  var builder = new JsonBuilder();

		  if (version === 1) version = '1.0';
		  httpRequest.body = builder.build(req.params || {}, input);
		  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
		  httpRequest.headers['X-Amz-Target'] = target;

		  populateHostPrefix(req);
		}

		function extractError(resp) {
		  var error = {};
		  var httpResponse = resp.httpResponse;

		  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
		  if (typeof error.code === 'string') {
		    error.code = error.code.split(':')[0];
		  }

		  if (httpResponse.body.length > 0) {
		    try {
		      var e = JSON.parse(httpResponse.body.toString());
		      var code = e.__type || e.code || e.Code;
		      if (code) {
		        error.code = code.split('#').pop();
		      }
		      if (error.code === 'RequestEntityTooLarge') {
		        error.message = 'Request body must be less than 1 MB';
		      } else {
		        error.message = (e.message || e.Message || null);
		      }
		    } catch (e) {
		      error.statusCode = httpResponse.statusCode;
		      error.message = httpResponse.statusMessage;
		    }
		  } else {
		    error.statusCode = httpResponse.statusCode;
		    error.message = httpResponse.statusCode.toString();
		  }

		  resp.error = util.error(new Error(), error);
		}

		function extractData(resp) {
		  var body = resp.httpResponse.body.toString() || '{}';
		  if (resp.request.service.config.convertResponseTypes === false) {
		    resp.data = JSON.parse(body);
		  } else {
		    var operation = resp.request.service.api.operations[resp.request.operation];
		    var shape = operation.output || {};
		    var parser = new JsonParser();
		    resp.data = parser.parse(body, shape);
		  }
		}

		/**
		 * @api private
		 */
		module.exports = {
		  buildRequest: buildRequest,
		  extractError: extractError,
		  extractData: extractData
		};


	/***/ }),
	/* 19 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);

		function JsonBuilder() { }

		JsonBuilder.prototype.build = function(value, shape) {
		  return JSON.stringify(translate(value, shape));
		};

		function translate(value, shape) {
		  if (!shape || value === undefined || value === null) return undefined;

		  switch (shape.type) {
		    case 'structure': return translateStructure(value, shape);
		    case 'map': return translateMap(value, shape);
		    case 'list': return translateList(value, shape);
		    default: return translateScalar(value, shape);
		  }
		}

		function translateStructure(structure, shape) {
		  if (shape.isDocument) {
		    return structure;
		  }
		  var struct = {};
		  util.each(structure, function(name, value) {
		    var memberShape = shape.members[name];
		    if (memberShape) {
		      if (memberShape.location !== 'body') return;
		      var locationName = memberShape.isLocationName ? memberShape.name : name;
		      var result = translate(value, memberShape);
		      if (result !== undefined) struct[locationName] = result;
		    }
		  });
		  return struct;
		}

		function translateList(list, shape) {
		  var out = [];
		  util.arrayEach(list, function(value) {
		    var result = translate(value, shape.member);
		    if (result !== undefined) out.push(result);
		  });
		  return out;
		}

		function translateMap(map, shape) {
		  var out = {};
		  util.each(map, function(key, value) {
		    var result = translate(value, shape.value);
		    if (result !== undefined) out[key] = result;
		  });
		  return out;
		}

		function translateScalar(value, shape) {
		  return shape.toWireFormat(value);
		}

		/**
		 * @api private
		 */
		module.exports = JsonBuilder;


	/***/ }),
	/* 20 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);

		function JsonParser() { }

		JsonParser.prototype.parse = function(value, shape) {
		  return translate(JSON.parse(value), shape);
		};

		function translate(value, shape) {
		  if (!shape || value === undefined) return undefined;

		  switch (shape.type) {
		    case 'structure': return translateStructure(value, shape);
		    case 'map': return translateMap(value, shape);
		    case 'list': return translateList(value, shape);
		    default: return translateScalar(value, shape);
		  }
		}

		function translateStructure(structure, shape) {
		  if (structure == null) return undefined;
		  if (shape.isDocument) return structure;

		  var struct = {};
		  var shapeMembers = shape.members;
		  util.each(shapeMembers, function(name, memberShape) {
		    var locationName = memberShape.isLocationName ? memberShape.name : name;
		    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
		      var value = structure[locationName];
		      var result = translate(value, memberShape);
		      if (result !== undefined) struct[name] = result;
		    }
		  });
		  return struct;
		}

		function translateList(list, shape) {
		  if (list == null) return undefined;

		  var out = [];
		  util.arrayEach(list, function(value) {
		    var result = translate(value, shape.member);
		    if (result === undefined) out.push(null);
		    else out.push(result);
		  });
		  return out;
		}

		function translateMap(map, shape) {
		  if (map == null) return undefined;

		  var out = {};
		  util.each(map, function(key, value) {
		    var result = translate(value, shape.value);
		    if (result === undefined) out[key] = null;
		    else out[key] = result;
		  });
		  return out;
		}

		function translateScalar(value, shape) {
		  return shape.toType(value);
		}

		/**
		 * @api private
		 */
		module.exports = JsonParser;


	/***/ }),
	/* 21 */
	/***/ (function(module, exports, __webpack_require__) {

		var util =  __webpack_require__(2);
		var AWS = __webpack_require__(1);

		/**
		 * Prepend prefix defined by API model to endpoint that's already
		 * constructed. This feature does not apply to operations using
		 * endpoint discovery and can be disabled.
		 * @api private
		 */
		function populateHostPrefix(request)  {
		  var enabled = request.service.config.hostPrefixEnabled;
		  if (!enabled) return request;
		  var operationModel = request.service.api.operations[request.operation];
		  //don't marshal host prefix when operation has endpoint discovery traits
		  if (hasEndpointDiscover(request)) return request;
		  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
		    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
		    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
		    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
		    validateHostname(request.httpRequest.endpoint.hostname);
		  }
		  return request;
		}

		/**
		 * @api private
		 */
		function hasEndpointDiscover(request) {
		  var api = request.service.api;
		  var operationModel = api.operations[request.operation];
		  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
		  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
		}

		/**
		 * @api private
		 */
		function expandHostPrefix(hostPrefixNotation, params, shape) {
		  util.each(shape.members, function(name, member) {
		    if (member.hostLabel === true) {
		      if (typeof params[name] !== 'string' || params[name] === '') {
		        throw util.error(new Error(), {
		          message: 'Parameter ' + name + ' should be a non-empty string.',
		          code: 'InvalidParameter'
		        });
		      }
		      var regex = new RegExp('\\{' + name + '\\}', 'g');
		      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
		    }
		  });
		  return hostPrefixNotation;
		}

		/**
		 * @api private
		 */
		function prependEndpointPrefix(endpoint, prefix) {
		  if (endpoint.host) {
		    endpoint.host = prefix + endpoint.host;
		  }
		  if (endpoint.hostname) {
		    endpoint.hostname = prefix + endpoint.hostname;
		  }
		}

		/**
		 * @api private
		 */
		function validateHostname(hostname) {
		  var labels = hostname.split('.');
		  //Reference: https://tools.ietf.org/html/rfc1123#section-2
		  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
		  util.arrayEach(labels, function(label) {
		    if (!label.length || label.length < 1 || label.length > 63) {
		      throw util.error(new Error(), {
		        code: 'ValidationError',
		        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
		      });
		    }
		    if (!hostPattern.test(label)) {
		      throw AWS.util.error(new Error(),
		        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
		    }
		  });
		}

		module.exports = {
		  populateHostPrefix: populateHostPrefix
		};


	/***/ }),
	/* 22 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);
		var util = __webpack_require__(2);
		var QueryParamSerializer = __webpack_require__(23);
		var Shape = __webpack_require__(24);
		var populateHostPrefix = __webpack_require__(21).populateHostPrefix;

		function buildRequest(req) {
		  var operation = req.service.api.operations[req.operation];
		  var httpRequest = req.httpRequest;
		  httpRequest.headers['Content-Type'] =
		    'application/x-www-form-urlencoded; charset=utf-8';
		  httpRequest.params = {
		    Version: req.service.api.apiVersion,
		    Action: operation.name
		  };

		  // convert the request parameters into a list of query params,
		  // e.g. Deeply.NestedParam.0.Name=value
		  var builder = new QueryParamSerializer();
		  builder.serialize(req.params, operation.input, function(name, value) {
		    httpRequest.params[name] = value;
		  });
		  httpRequest.body = util.queryParamsToString(httpRequest.params);

		  populateHostPrefix(req);
		}

		function extractError(resp) {
		  var data, body = resp.httpResponse.body.toString();
		  if (body.match('<UnknownOperationException')) {
		    data = {
		      Code: 'UnknownOperation',
		      Message: 'Unknown operation ' + resp.request.operation
		    };
		  } else {
		    try {
		      data = new AWS.XML.Parser().parse(body);
		    } catch (e) {
		      data = {
		        Code: resp.httpResponse.statusCode,
		        Message: resp.httpResponse.statusMessage
		      };
		    }
		  }

		  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
		  if (data.Errors) data = data.Errors;
		  if (data.Error) data = data.Error;
		  if (data.Code) {
		    resp.error = util.error(new Error(), {
		      code: data.Code,
		      message: data.Message
		    });
		  } else {
		    resp.error = util.error(new Error(), {
		      code: resp.httpResponse.statusCode,
		      message: null
		    });
		  }
		}

		function extractData(resp) {
		  var req = resp.request;
		  var operation = req.service.api.operations[req.operation];
		  var shape = operation.output || {};
		  var origRules = shape;

		  if (origRules.resultWrapper) {
		    var tmp = Shape.create({type: 'structure'});
		    tmp.members[origRules.resultWrapper] = shape;
		    tmp.memberNames = [origRules.resultWrapper];
		    util.property(shape, 'name', shape.resultWrapper);
		    shape = tmp;
		  }

		  var parser = new AWS.XML.Parser();

		  // TODO: Refactor XML Parser to parse RequestId from response.
		  if (shape && shape.members && !shape.members._XAMZRequestId) {
		    var requestIdShape = Shape.create(
		      { type: 'string' },
		      { api: { protocol: 'query' } },
		      'requestId'
		    );
		    shape.members._XAMZRequestId = requestIdShape;
		  }

		  var data = parser.parse(resp.httpResponse.body.toString(), shape);
		  resp.requestId = data._XAMZRequestId || data.requestId;

		  if (data._XAMZRequestId) delete data._XAMZRequestId;

		  if (origRules.resultWrapper) {
		    if (data[origRules.resultWrapper]) {
		      util.update(data, data[origRules.resultWrapper]);
		      delete data[origRules.resultWrapper];
		    }
		  }

		  resp.data = data;
		}

		/**
		 * @api private
		 */
		module.exports = {
		  buildRequest: buildRequest,
		  extractError: extractError,
		  extractData: extractData
		};


	/***/ }),
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);

		function QueryParamSerializer() {
		}

		QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
		  serializeStructure('', params, shape, fn);
		};

		function ucfirst(shape) {
		  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
		    return shape.name;
		  } else {
		    return shape.name[0].toUpperCase() + shape.name.substr(1);
		  }
		}

		function serializeStructure(prefix, struct, rules, fn) {
		  util.each(rules.members, function(name, member) {
		    var value = struct[name];
		    if (value === null || value === undefined) return;

		    var memberName = ucfirst(member);
		    memberName = prefix ? prefix + '.' + memberName : memberName;
		    serializeMember(memberName, value, member, fn);
		  });
		}

		function serializeMap(name, map, rules, fn) {
		  var i = 1;
		  util.each(map, function (key, value) {
		    var prefix = rules.flattened ? '.' : '.entry.';
		    var position = prefix + (i++) + '.';
		    var keyName = position + (rules.key.name || 'key');
		    var valueName = position + (rules.value.name || 'value');
		    serializeMember(name + keyName, key, rules.key, fn);
		    serializeMember(name + valueName, value, rules.value, fn);
		  });
		}

		function serializeList(name, list, rules, fn) {
		  var memberRules = rules.member || {};

		  if (list.length === 0) {
		    fn.call(this, name, null);
		    return;
		  }

		  util.arrayEach(list, function (v, n) {
		    var suffix = '.' + (n + 1);
		    if (rules.api.protocol === 'ec2') {
		      // Do nothing for EC2
		      suffix = suffix + ''; // make linter happy
		    } else if (rules.flattened) {
		      if (memberRules.name) {
		        var parts = name.split('.');
		        parts.pop();
		        parts.push(ucfirst(memberRules));
		        name = parts.join('.');
		      }
		    } else {
		      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
		    }
		    serializeMember(name + suffix, v, memberRules, fn);
		  });
		}

		function serializeMember(name, value, rules, fn) {
		  if (value === null || value === undefined) return;
		  if (rules.type === 'structure') {
		    serializeStructure(name, value, rules, fn);
		  } else if (rules.type === 'list') {
		    serializeList(name, value, rules, fn);
		  } else if (rules.type === 'map') {
		    serializeMap(name, value, rules, fn);
		  } else {
		    fn(name, rules.toWireFormat(value).toString());
		  }
		}

		/**
		 * @api private
		 */
		module.exports = QueryParamSerializer;


	/***/ }),
	/* 24 */
	/***/ (function(module, exports, __webpack_require__) {

		var Collection = __webpack_require__(25);

		var util = __webpack_require__(2);

		function property(obj, name, value) {
		  if (value !== null && value !== undefined) {
		    util.property.apply(this, arguments);
		  }
		}

		function memoizedProperty(obj, name) {
		  if (!obj.constructor.prototype[name]) {
		    util.memoizedProperty.apply(this, arguments);
		  }
		}

		function Shape(shape, options, memberName) {
		  options = options || {};

		  property(this, 'shape', shape.shape);
		  property(this, 'api', options.api, false);
		  property(this, 'type', shape.type);
		  property(this, 'enum', shape.enum);
		  property(this, 'min', shape.min);
		  property(this, 'max', shape.max);
		  property(this, 'pattern', shape.pattern);
		  property(this, 'location', shape.location || this.location || 'body');
		  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
		    shape.locationName || memberName);
		  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
		  property(this, 'requiresLength', shape.requiresLength, false);
		  property(this, 'isComposite', shape.isComposite || false);
		  property(this, 'isShape', true, false);
		  property(this, 'isQueryName', Boolean(shape.queryName), false);
		  property(this, 'isLocationName', Boolean(shape.locationName), false);
		  property(this, 'isIdempotent', shape.idempotencyToken === true);
		  property(this, 'isJsonValue', shape.jsonvalue === true);
		  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
		  property(this, 'isEventStream', Boolean(shape.eventstream), false);
		  property(this, 'isEvent', Boolean(shape.event), false);
		  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
		  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
		  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
		  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
		  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

		  if (options.documentation) {
		    property(this, 'documentation', shape.documentation);
		    property(this, 'documentationUrl', shape.documentationUrl);
		  }

		  if (shape.xmlAttribute) {
		    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
		  }

		  // type conversion and parsing
		  property(this, 'defaultValue', null);
		  this.toWireFormat = function(value) {
		    if (value === null || value === undefined) return '';
		    return value;
		  };
		  this.toType = function(value) { return value; };
		}

		/**
		 * @api private
		 */
		Shape.normalizedTypes = {
		  character: 'string',
		  double: 'float',
		  long: 'integer',
		  short: 'integer',
		  biginteger: 'integer',
		  bigdecimal: 'float',
		  blob: 'binary'
		};

		/**
		 * @api private
		 */
		Shape.types = {
		  'structure': StructureShape,
		  'list': ListShape,
		  'map': MapShape,
		  'boolean': BooleanShape,
		  'timestamp': TimestampShape,
		  'float': FloatShape,
		  'integer': IntegerShape,
		  'string': StringShape,
		  'base64': Base64Shape,
		  'binary': BinaryShape
		};

		Shape.resolve = function resolve(shape, options) {
		  if (shape.shape) {
		    var refShape = options.api.shapes[shape.shape];
		    if (!refShape) {
		      throw new Error('Cannot find shape reference: ' + shape.shape);
		    }

		    return refShape;
		  } else {
		    return null;
		  }
		};

		Shape.create = function create(shape, options, memberName) {
		  if (shape.isShape) return shape;

		  var refShape = Shape.resolve(shape, options);
		  if (refShape) {
		    var filteredKeys = Object.keys(shape);
		    if (!options.documentation) {
		      filteredKeys = filteredKeys.filter(function(name) {
		        return !name.match(/documentation/);
		      });
		    }

		    // create an inline shape with extra members
		    var InlineShape = function() {
		      refShape.constructor.call(this, shape, options, memberName);
		    };
		    InlineShape.prototype = refShape;
		    return new InlineShape();
		  } else {
		    // set type if not set
		    if (!shape.type) {
		      if (shape.members) shape.type = 'structure';
		      else if (shape.member) shape.type = 'list';
		      else if (shape.key) shape.type = 'map';
		      else shape.type = 'string';
		    }

		    // normalize types
		    var origType = shape.type;
		    if (Shape.normalizedTypes[shape.type]) {
		      shape.type = Shape.normalizedTypes[shape.type];
		    }

		    if (Shape.types[shape.type]) {
		      return new Shape.types[shape.type](shape, options, memberName);
		    } else {
		      throw new Error('Unrecognized shape type: ' + origType);
		    }
		  }
		};

		function CompositeShape(shape) {
		  Shape.apply(this, arguments);
		  property(this, 'isComposite', true);

		  if (shape.flattened) {
		    property(this, 'flattened', shape.flattened || false);
		  }
		}

		function StructureShape(shape, options) {
		  var self = this;
		  var requiredMap = null, firstInit = !this.isShape;

		  CompositeShape.apply(this, arguments);

		  if (firstInit) {
		    property(this, 'defaultValue', function() { return {}; });
		    property(this, 'members', {});
		    property(this, 'memberNames', []);
		    property(this, 'required', []);
		    property(this, 'isRequired', function() { return false; });
		    property(this, 'isDocument', Boolean(shape.document));
		  }

		  if (shape.members) {
		    property(this, 'members', new Collection(shape.members, options, function(name, member) {
		      return Shape.create(member, options, name);
		    }));
		    memoizedProperty(this, 'memberNames', function() {
		      return shape.xmlOrder || Object.keys(shape.members);
		    });

		    if (shape.event) {
		      memoizedProperty(this, 'eventPayloadMemberName', function() {
		        var members = self.members;
		        var memberNames = self.memberNames;
		        // iterate over members to find ones that are event payloads
		        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
		          if (members[memberNames[i]].isEventPayload) {
		            return memberNames[i];
		          }
		        }
		      });

		      memoizedProperty(this, 'eventHeaderMemberNames', function() {
		        var members = self.members;
		        var memberNames = self.memberNames;
		        var eventHeaderMemberNames = [];
		        // iterate over members to find ones that are event headers
		        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
		          if (members[memberNames[i]].isEventHeader) {
		            eventHeaderMemberNames.push(memberNames[i]);
		          }
		        }
		        return eventHeaderMemberNames;
		      });
		    }
		  }

		  if (shape.required) {
		    property(this, 'required', shape.required);
		    property(this, 'isRequired', function(name) {
		      if (!requiredMap) {
		        requiredMap = {};
		        for (var i = 0; i < shape.required.length; i++) {
		          requiredMap[shape.required[i]] = true;
		        }
		      }

		      return requiredMap[name];
		    }, false, true);
		  }

		  property(this, 'resultWrapper', shape.resultWrapper || null);

		  if (shape.payload) {
		    property(this, 'payload', shape.payload);
		  }

		  if (typeof shape.xmlNamespace === 'string') {
		    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
		  } else if (typeof shape.xmlNamespace === 'object') {
		    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
		    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
		  }
		}

		function ListShape(shape, options) {
		  var self = this, firstInit = !this.isShape;
		  CompositeShape.apply(this, arguments);

		  if (firstInit) {
		    property(this, 'defaultValue', function() { return []; });
		  }

		  if (shape.member) {
		    memoizedProperty(this, 'member', function() {
		      return Shape.create(shape.member, options);
		    });
		  }

		  if (this.flattened) {
		    var oldName = this.name;
		    memoizedProperty(this, 'name', function() {
		      return self.member.name || oldName;
		    });
		  }
		}

		function MapShape(shape, options) {
		  var firstInit = !this.isShape;
		  CompositeShape.apply(this, arguments);

		  if (firstInit) {
		    property(this, 'defaultValue', function() { return {}; });
		    property(this, 'key', Shape.create({type: 'string'}, options));
		    property(this, 'value', Shape.create({type: 'string'}, options));
		  }

		  if (shape.key) {
		    memoizedProperty(this, 'key', function() {
		      return Shape.create(shape.key, options);
		    });
		  }
		  if (shape.value) {
		    memoizedProperty(this, 'value', function() {
		      return Shape.create(shape.value, options);
		    });
		  }
		}

		function TimestampShape(shape) {
		  var self = this;
		  Shape.apply(this, arguments);

		  if (shape.timestampFormat) {
		    property(this, 'timestampFormat', shape.timestampFormat);
		  } else if (self.isTimestampFormatSet && this.timestampFormat) {
		    property(this, 'timestampFormat', this.timestampFormat);
		  } else if (this.location === 'header') {
		    property(this, 'timestampFormat', 'rfc822');
		  } else if (this.location === 'querystring') {
		    property(this, 'timestampFormat', 'iso8601');
		  } else if (this.api) {
		    switch (this.api.protocol) {
		      case 'json':
		      case 'rest-json':
		        property(this, 'timestampFormat', 'unixTimestamp');
		        break;
		      case 'rest-xml':
		      case 'query':
		      case 'ec2':
		        property(this, 'timestampFormat', 'iso8601');
		        break;
		    }
		  }

		  this.toType = function(value) {
		    if (value === null || value === undefined) return null;
		    if (typeof value.toUTCString === 'function') return value;
		    return typeof value === 'string' || typeof value === 'number' ?
		           util.date.parseTimestamp(value) : null;
		  };

		  this.toWireFormat = function(value) {
		    return util.date.format(value, self.timestampFormat);
		  };
		}

		function StringShape() {
		  Shape.apply(this, arguments);

		  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
		  this.toType = function(value) {
		    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
		      value || '' : value;
		    if (this.isJsonValue) {
		      return JSON.parse(value);
		    }

		    return value && typeof value.toString === 'function' ?
		      value.toString() : value;
		  };

		  this.toWireFormat = function(value) {
		    return this.isJsonValue ? JSON.stringify(value) : value;
		  };
		}

		function FloatShape() {
		  Shape.apply(this, arguments);

		  this.toType = function(value) {
		    if (value === null || value === undefined) return null;
		    return parseFloat(value);
		  };
		  this.toWireFormat = this.toType;
		}

		function IntegerShape() {
		  Shape.apply(this, arguments);

		  this.toType = function(value) {
		    if (value === null || value === undefined) return null;
		    return parseInt(value, 10);
		  };
		  this.toWireFormat = this.toType;
		}

		function BinaryShape() {
		  Shape.apply(this, arguments);
		  this.toType = function(value) {
		    var buf = util.base64.decode(value);
		    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
		  /* Node.js can create a Buffer that is not isolated.
		   * i.e. buf.byteLength !== buf.buffer.byteLength
		   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
		   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
		   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
		   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
		   */
		      var secureBuf = util.Buffer.alloc(buf.length, buf);
		      buf.fill(0);
		      buf = secureBuf;
		    }
		    return buf;
		  };
		  this.toWireFormat = util.base64.encode;
		}

		function Base64Shape() {
		  BinaryShape.apply(this, arguments);
		}

		function BooleanShape() {
		  Shape.apply(this, arguments);

		  this.toType = function(value) {
		    if (typeof value === 'boolean') return value;
		    if (value === null || value === undefined) return null;
		    return value === 'true';
		  };
		}

		/**
		 * @api private
		 */
		Shape.shapes = {
		  StructureShape: StructureShape,
		  ListShape: ListShape,
		  MapShape: MapShape,
		  StringShape: StringShape,
		  BooleanShape: BooleanShape,
		  Base64Shape: Base64Shape
		};

		/**
		 * @api private
		 */
		module.exports = Shape;


	/***/ }),
	/* 25 */
	/***/ (function(module, exports, __webpack_require__) {

		var memoizedProperty = __webpack_require__(2).memoizedProperty;

		function memoize(name, value, factory, nameTr) {
		  memoizedProperty(this, nameTr(name), function() {
		    return factory(name, value);
		  });
		}

		function Collection(iterable, options, factory, nameTr, callback) {
		  nameTr = nameTr || String;
		  var self = this;

		  for (var id in iterable) {
		    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
		      memoize.call(self, id, iterable[id], factory, nameTr);
		      if (callback) callback(id, iterable[id]);
		    }
		  }
		}

		/**
		 * @api private
		 */
		module.exports = Collection;


	/***/ }),
	/* 26 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var populateHostPrefix = __webpack_require__(21).populateHostPrefix;

		function populateMethod(req) {
		  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
		}

		function generateURI(endpointPath, operationPath, input, params) {
		  var uri = [endpointPath, operationPath].join('/');
		  uri = uri.replace(/\/+/g, '/');

		  var queryString = {}, queryStringSet = false;
		  util.each(input.members, function (name, member) {
		    var paramValue = params[name];
		    if (paramValue === null || paramValue === undefined) return;
		    if (member.location === 'uri') {
		      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
		      uri = uri.replace(regex, function(_, plus) {
		        var fn = plus ? util.uriEscapePath : util.uriEscape;
		        return fn(String(paramValue));
		      });
		    } else if (member.location === 'querystring') {
		      queryStringSet = true;

		      if (member.type === 'list') {
		        queryString[member.name] = paramValue.map(function(val) {
		          return util.uriEscape(member.member.toWireFormat(val).toString());
		        });
		      } else if (member.type === 'map') {
		        util.each(paramValue, function(key, value) {
		          if (Array.isArray(value)) {
		            queryString[key] = value.map(function(val) {
		              return util.uriEscape(String(val));
		            });
		          } else {
		            queryString[key] = util.uriEscape(String(value));
		          }
		        });
		      } else {
		        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
		      }
		    }
		  });

		  if (queryStringSet) {
		    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
		    var parts = [];
		    util.arrayEach(Object.keys(queryString).sort(), function(key) {
		      if (!Array.isArray(queryString[key])) {
		        queryString[key] = [queryString[key]];
		      }
		      for (var i = 0; i < queryString[key].length; i++) {
		        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
		      }
		    });
		    uri += parts.join('&');
		  }

		  return uri;
		}

		function populateURI(req) {
		  var operation = req.service.api.operations[req.operation];
		  var input = operation.input;

		  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
		  req.httpRequest.path = uri;
		}

		function populateHeaders(req) {
		  var operation = req.service.api.operations[req.operation];
		  util.each(operation.input.members, function (name, member) {
		    var value = req.params[name];
		    if (value === null || value === undefined) return;

		    if (member.location === 'headers' && member.type === 'map') {
		      util.each(value, function(key, memberValue) {
		        req.httpRequest.headers[member.name + key] = memberValue;
		      });
		    } else if (member.location === 'header') {
		      value = member.toWireFormat(value).toString();
		      if (member.isJsonValue) {
		        value = util.base64.encode(value);
		      }
		      req.httpRequest.headers[member.name] = value;
		    }
		  });
		}

		function buildRequest(req) {
		  populateMethod(req);
		  populateURI(req);
		  populateHeaders(req);
		  populateHostPrefix(req);
		}

		function extractError() {
		}

		function extractData(resp) {
		  var req = resp.request;
		  var data = {};
		  var r = resp.httpResponse;
		  var operation = req.service.api.operations[req.operation];
		  var output = operation.output;

		  // normalize headers names to lower-cased keys for matching
		  var headers = {};
		  util.each(r.headers, function (k, v) {
		    headers[k.toLowerCase()] = v;
		  });

		  util.each(output.members, function(name, member) {
		    var header = (member.name || name).toLowerCase();
		    if (member.location === 'headers' && member.type === 'map') {
		      data[name] = {};
		      var location = member.isLocationName ? member.name : '';
		      var pattern = new RegExp('^' + location + '(.+)', 'i');
		      util.each(r.headers, function (k, v) {
		        var result = k.match(pattern);
		        if (result !== null) {
		          data[name][result[1]] = v;
		        }
		      });
		    } else if (member.location === 'header') {
		      if (headers[header] !== undefined) {
		        var value = member.isJsonValue ?
		          util.base64.decode(headers[header]) :
		          headers[header];
		        data[name] = member.toType(value);
		      }
		    } else if (member.location === 'statusCode') {
		      data[name] = parseInt(r.statusCode, 10);
		    }
		  });

		  resp.data = data;
		}

		/**
		 * @api private
		 */
		module.exports = {
		  buildRequest: buildRequest,
		  extractError: extractError,
		  extractData: extractData,
		  generateURI: generateURI
		};


	/***/ }),
	/* 27 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var Rest = __webpack_require__(26);
		var Json = __webpack_require__(18);
		var JsonBuilder = __webpack_require__(19);
		var JsonParser = __webpack_require__(20);

		var METHODS_WITHOUT_BODY = ['GET', 'HEAD', 'DELETE'];

		function unsetContentLength(req) {
		  var payloadMember = util.getRequestPayloadShape(req);
		  if (
		    payloadMember === undefined &&
		    METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) >= 0
		  ) {
		    delete req.httpRequest.headers['Content-Length'];
		  }
		}

		function populateBody(req) {
		  var builder = new JsonBuilder();
		  var input = req.service.api.operations[req.operation].input;

		  if (input.payload) {
		    var params = {};
		    var payloadShape = input.members[input.payload];
		    params = req.params[input.payload];

		    if (payloadShape.type === 'structure') {
		      req.httpRequest.body = builder.build(params || {}, payloadShape);
		      applyContentTypeHeader(req);
		    } else if (params !== undefined) {
		      // non-JSON payload
		      req.httpRequest.body = params;
		      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
		        applyContentTypeHeader(req, true);
		      }
		    }
		  } else {
		    req.httpRequest.body = builder.build(req.params, input);
		    applyContentTypeHeader(req);
		  }
		}

		function applyContentTypeHeader(req, isBinary) {
		  if (!req.httpRequest.headers['Content-Type']) {
		    var type = isBinary ? 'binary/octet-stream' : 'application/json';
		    req.httpRequest.headers['Content-Type'] = type;
		  }
		}

		function buildRequest(req) {
		  Rest.buildRequest(req);

		  // never send body payload on GET/HEAD/DELETE
		  if (METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) < 0) {
		    populateBody(req);
		  }
		}

		function extractError(resp) {
		  Json.extractError(resp);
		}

		function extractData(resp) {
		  Rest.extractData(resp);

		  var req = resp.request;
		  var operation = req.service.api.operations[req.operation];
		  var rules = req.service.api.operations[req.operation].output || {};
		  var parser;
		  var hasEventOutput = operation.hasEventOutput;

		  if (rules.payload) {
		    var payloadMember = rules.members[rules.payload];
		    var body = resp.httpResponse.body;
		    if (payloadMember.isEventStream) {
		      parser = new JsonParser();
		      resp.data[payload] = util.createEventStream(
		        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
		        parser,
		        payloadMember
		      );
		    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
		      var parser = new JsonParser();
		      resp.data[rules.payload] = parser.parse(body, payloadMember);
		    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
		      resp.data[rules.payload] = body;
		    } else {
		      resp.data[rules.payload] = payloadMember.toType(body);
		    }
		  } else {
		    var data = resp.data;
		    Json.extractData(resp);
		    resp.data = util.merge(data, resp.data);
		  }
		}

		/**
		 * @api private
		 */
		module.exports = {
		  buildRequest: buildRequest,
		  extractError: extractError,
		  extractData: extractData,
		  unsetContentLength: unsetContentLength
		};


	/***/ }),
	/* 28 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);
		var util = __webpack_require__(2);
		var Rest = __webpack_require__(26);

		function populateBody(req) {
		  var input = req.service.api.operations[req.operation].input;
		  var builder = new AWS.XML.Builder();
		  var params = req.params;

		  var payload = input.payload;
		  if (payload) {
		    var payloadMember = input.members[payload];
		    params = params[payload];
		    if (params === undefined) return;

		    if (payloadMember.type === 'structure') {
		      var rootElement = payloadMember.name;
		      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
		    } else { // non-xml payload
		      req.httpRequest.body = params;
		    }
		  } else {
		    req.httpRequest.body = builder.toXML(params, input, input.name ||
		      input.shape || util.string.upperFirst(req.operation) + 'Request');
		  }
		}

		function buildRequest(req) {
		  Rest.buildRequest(req);

		  // never send body payload on GET/HEAD
		  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
		    populateBody(req);
		  }
		}

		function extractError(resp) {
		  Rest.extractError(resp);

		  var data;
		  try {
		    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
		  } catch (e) {
		    data = {
		      Code: resp.httpResponse.statusCode,
		      Message: resp.httpResponse.statusMessage
		    };
		  }

		  if (data.Errors) data = data.Errors;
		  if (data.Error) data = data.Error;
		  if (data.Code) {
		    resp.error = util.error(new Error(), {
		      code: data.Code,
		      message: data.Message
		    });
		  } else {
		    resp.error = util.error(new Error(), {
		      code: resp.httpResponse.statusCode,
		      message: null
		    });
		  }
		}

		function extractData(resp) {
		  Rest.extractData(resp);

		  var parser;
		  var req = resp.request;
		  var body = resp.httpResponse.body;
		  var operation = req.service.api.operations[req.operation];
		  var output = operation.output;

		  var hasEventOutput = operation.hasEventOutput;

		  var payload = output.payload;
		  if (payload) {
		    var payloadMember = output.members[payload];
		    if (payloadMember.isEventStream) {
		      parser = new AWS.XML.Parser();
		      resp.data[payload] = util.createEventStream(
		        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
		        parser,
		        payloadMember
		      );
		    } else if (payloadMember.type === 'structure') {
		      parser = new AWS.XML.Parser();
		      resp.data[payload] = parser.parse(body.toString(), payloadMember);
		    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
		      resp.data[payload] = body;
		    } else {
		      resp.data[payload] = payloadMember.toType(body);
		    }
		  } else if (body.length > 0) {
		    parser = new AWS.XML.Parser();
		    var data = parser.parse(body.toString(), output);
		    util.update(resp.data, data);
		  }
		}

		/**
		 * @api private
		 */
		module.exports = {
		  buildRequest: buildRequest,
		  extractError: extractError,
		  extractData: extractData
		};


	/***/ }),
	/* 29 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var XmlNode = __webpack_require__(30).XmlNode;
		var XmlText = __webpack_require__(32).XmlText;

		function XmlBuilder() { }

		XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
		  var xml = new XmlNode(rootElement);
		  applyNamespaces(xml, shape, true);
		  serialize(xml, params, shape);
		  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
		};

		function serialize(xml, value, shape) {
		  switch (shape.type) {
		    case 'structure': return serializeStructure(xml, value, shape);
		    case 'map': return serializeMap(xml, value, shape);
		    case 'list': return serializeList(xml, value, shape);
		    default: return serializeScalar(xml, value, shape);
		  }
		}

		function serializeStructure(xml, params, shape) {
		  util.arrayEach(shape.memberNames, function(memberName) {
		    var memberShape = shape.members[memberName];
		    if (memberShape.location !== 'body') return;

		    var value = params[memberName];
		    var name = memberShape.name;
		    if (value !== undefined && value !== null) {
		      if (memberShape.isXmlAttribute) {
		        xml.addAttribute(name, value);
		      } else if (memberShape.flattened) {
		        serialize(xml, value, memberShape);
		      } else {
		        var element = new XmlNode(name);
		        xml.addChildNode(element);
		        applyNamespaces(element, memberShape);
		        serialize(element, value, memberShape);
		      }
		    }
		  });
		}

		function serializeMap(xml, map, shape) {
		  var xmlKey = shape.key.name || 'key';
		  var xmlValue = shape.value.name || 'value';

		  util.each(map, function(key, value) {
		    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
		    xml.addChildNode(entry);

		    var entryKey = new XmlNode(xmlKey);
		    var entryValue = new XmlNode(xmlValue);
		    entry.addChildNode(entryKey);
		    entry.addChildNode(entryValue);

		    serialize(entryKey, key, shape.key);
		    serialize(entryValue, value, shape.value);
		  });
		}

		function serializeList(xml, list, shape) {
		  if (shape.flattened) {
		    util.arrayEach(list, function(value) {
		      var name = shape.member.name || shape.name;
		      var element = new XmlNode(name);
		      xml.addChildNode(element);
		      serialize(element, value, shape.member);
		    });
		  } else {
		    util.arrayEach(list, function(value) {
		      var name = shape.member.name || 'member';
		      var element = new XmlNode(name);
		      xml.addChildNode(element);
		      serialize(element, value, shape.member);
		    });
		  }
		}

		function serializeScalar(xml, value, shape) {
		  xml.addChildNode(
		    new XmlText(shape.toWireFormat(value))
		  );
		}

		function applyNamespaces(xml, shape, isRoot) {
		  var uri, prefix = 'xmlns';
		  if (shape.xmlNamespaceUri) {
		    uri = shape.xmlNamespaceUri;
		    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
		  } else if (isRoot && shape.api.xmlNamespaceUri) {
		    uri = shape.api.xmlNamespaceUri;
		  }

		  if (uri) xml.addAttribute(prefix, uri);
		}

		/**
		 * @api private
		 */
		module.exports = XmlBuilder;


	/***/ }),
	/* 30 */
	/***/ (function(module, exports, __webpack_require__) {

		var escapeAttribute = __webpack_require__(31).escapeAttribute;

		/**
		 * Represents an XML node.
		 * @api private
		 */
		function XmlNode(name, children) {
		    if (children === void 0) { children = []; }
		    this.name = name;
		    this.children = children;
		    this.attributes = {};
		}
		XmlNode.prototype.addAttribute = function (name, value) {
		    this.attributes[name] = value;
		    return this;
		};
		XmlNode.prototype.addChildNode = function (child) {
		    this.children.push(child);
		    return this;
		};
		XmlNode.prototype.removeAttribute = function (name) {
		    delete this.attributes[name];
		    return this;
		};
		XmlNode.prototype.toString = function () {
		    var hasChildren = Boolean(this.children.length);
		    var xmlText = '<' + this.name;
		    // add attributes
		    var attributes = this.attributes;
		    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
		        var attributeName = attributeNames[i];
		        var attribute = attributes[attributeName];
		        if (typeof attribute !== 'undefined' && attribute !== null) {
		            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
		        }
		    }
		    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
		};

		/**
		 * @api private
		 */
		module.exports = {
		    XmlNode: XmlNode
		};


	/***/ }),
	/* 31 */
	/***/ (function(module, exports) {

		/**
		 * Escapes characters that can not be in an XML attribute.
		 */
		function escapeAttribute(value) {
		    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
		}

		/**
		 * @api private
		 */
		module.exports = {
		    escapeAttribute: escapeAttribute
		};


	/***/ }),
	/* 32 */
	/***/ (function(module, exports, __webpack_require__) {

		var escapeElement = __webpack_require__(33).escapeElement;

		/**
		 * Represents an XML text value.
		 * @api private
		 */
		function XmlText(value) {
		    this.value = value;
		}

		XmlText.prototype.toString = function () {
		    return escapeElement('' + this.value);
		};

		/**
		 * @api private
		 */
		module.exports = {
		    XmlText: XmlText
		};


	/***/ }),
	/* 33 */
	/***/ (function(module, exports) {

		/**
		 * Escapes characters that can not be in an XML element.
		 */
		function escapeElement(value) {
		    return value.replace(/&/g, '&amp;')
		                .replace(/</g, '&lt;')
		                .replace(/>/g, '&gt;')
		                .replace(/\r/g, '&#x0D;')
		                .replace(/\n/g, '&#x0A;')
		                .replace(/\u0085/g, '&#x85;')
		                .replace(/\u2028/, '&#x2028;');
		}

		/**
		 * @api private
		 */
		module.exports = {
		    escapeElement: escapeElement
		};


	/***/ }),
	/* 34 */
	/***/ (function(module, exports, __webpack_require__) {

		var Collection = __webpack_require__(25);
		var Operation = __webpack_require__(35);
		var Shape = __webpack_require__(24);
		var Paginator = __webpack_require__(36);
		var ResourceWaiter = __webpack_require__(37);
		var metadata = __webpack_require__(7);

		var util = __webpack_require__(2);
		var property = util.property;
		var memoizedProperty = util.memoizedProperty;

		function Api(api, options) {
		  var self = this;
		  api = api || {};
		  options = options || {};
		  options.api = this;

		  api.metadata = api.metadata || {};

		  var serviceIdentifier = options.serviceIdentifier;
		  delete options.serviceIdentifier;

		  property(this, 'isApi', true, false);
		  property(this, 'apiVersion', api.metadata.apiVersion);
		  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
		  property(this, 'signingName', api.metadata.signingName);
		  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
		  property(this, 'signatureVersion', api.metadata.signatureVersion);
		  property(this, 'jsonVersion', api.metadata.jsonVersion);
		  property(this, 'targetPrefix', api.metadata.targetPrefix);
		  property(this, 'protocol', api.metadata.protocol);
		  property(this, 'timestampFormat', api.metadata.timestampFormat);
		  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
		  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
		  property(this, 'fullName', api.metadata.serviceFullName);
		  property(this, 'serviceId', api.metadata.serviceId);
		  if (serviceIdentifier && metadata[serviceIdentifier]) {
		      property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
		  }

		  memoizedProperty(this, 'className', function() {
		    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
		    if (!name) return null;

		    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
		    if (name === 'ElasticLoadBalancing') name = 'ELB';
		    return name;
		  });

		  function addEndpointOperation(name, operation) {
		    if (operation.endpointoperation === true) {
		      property(self, 'endpointOperation', util.string.lowerFirst(name));
		    }
		    if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
		      property(
		        self,
		        'hasRequiredEndpointDiscovery',
		        operation.endpointdiscovery.required === true
		      );
		    }
		  }

		  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
		    return new Operation(name, operation, options);
		  }, util.string.lowerFirst, addEndpointOperation));

		  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
		    return Shape.create(shape, options);
		  }));

		  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
		    return new Paginator(name, paginator, options);
		  }));

		  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
		    return new ResourceWaiter(name, waiter, options);
		  }, util.string.lowerFirst));

		  if (options.documentation) {
		    property(this, 'documentation', api.documentation);
		    property(this, 'documentationUrl', api.documentationUrl);
		  }
		  property(this, 'awsQueryCompatible', api.metadata.awsQueryCompatible);
		}

		/**
		 * @api private
		 */
		module.exports = Api;


	/***/ }),
	/* 35 */
	/***/ (function(module, exports, __webpack_require__) {

		var Shape = __webpack_require__(24);

		var util = __webpack_require__(2);
		var property = util.property;
		var memoizedProperty = util.memoizedProperty;

		function Operation(name, operation, options) {
		  var self = this;
		  options = options || {};

		  property(this, 'name', operation.name || name);
		  property(this, 'api', options.api, false);

		  operation.http = operation.http || {};
		  property(this, 'endpoint', operation.endpoint);
		  property(this, 'httpMethod', operation.http.method || 'POST');
		  property(this, 'httpPath', operation.http.requestUri || '/');
		  property(this, 'authtype', operation.authtype || '');
		  property(
		    this,
		    'endpointDiscoveryRequired',
		    operation.endpointdiscovery ?
		      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
		    'NULL'
		  );

		  // httpChecksum replaces usage of httpChecksumRequired, but some APIs
		  // (s3control) still uses old trait.
		  var httpChecksumRequired = operation.httpChecksumRequired
		    || (operation.httpChecksum && operation.httpChecksum.requestChecksumRequired);
		  property(this, 'httpChecksumRequired', httpChecksumRequired, false);

		  memoizedProperty(this, 'input', function() {
		    if (!operation.input) {
		      return new Shape.create({type: 'structure'}, options);
		    }
		    return Shape.create(operation.input, options);
		  });

		  memoizedProperty(this, 'output', function() {
		    if (!operation.output) {
		      return new Shape.create({type: 'structure'}, options);
		    }
		    return Shape.create(operation.output, options);
		  });

		  memoizedProperty(this, 'errors', function() {
		    var list = [];
		    if (!operation.errors) return null;

		    for (var i = 0; i < operation.errors.length; i++) {
		      list.push(Shape.create(operation.errors[i], options));
		    }

		    return list;
		  });

		  memoizedProperty(this, 'paginator', function() {
		    return options.api.paginators[name];
		  });

		  if (options.documentation) {
		    property(this, 'documentation', operation.documentation);
		    property(this, 'documentationUrl', operation.documentationUrl);
		  }

		  // idempotentMembers only tracks top-level input shapes
		  memoizedProperty(this, 'idempotentMembers', function() {
		    var idempotentMembers = [];
		    var input = self.input;
		    var members = input.members;
		    if (!input.members) {
		      return idempotentMembers;
		    }
		    for (var name in members) {
		      if (!members.hasOwnProperty(name)) {
		        continue;
		      }
		      if (members[name].isIdempotent === true) {
		        idempotentMembers.push(name);
		      }
		    }
		    return idempotentMembers;
		  });

		  memoizedProperty(this, 'hasEventOutput', function() {
		    var output = self.output;
		    return hasEventStream(output);
		  });
		}

		function hasEventStream(topLevelShape) {
		  var members = topLevelShape.members;
		  var payload = topLevelShape.payload;

		  if (!topLevelShape.members) {
		    return false;
		  }

		  if (payload) {
		    var payloadMember = members[payload];
		    return payloadMember.isEventStream;
		  }

		  // check if any member is an event stream
		  for (var name in members) {
		    if (!members.hasOwnProperty(name)) {
		      if (members[name].isEventStream === true) {
		        return true;
		      }
		    }
		  }
		  return false;
		}

		/**
		 * @api private
		 */
		module.exports = Operation;


	/***/ }),
	/* 36 */
	/***/ (function(module, exports, __webpack_require__) {

		var property = __webpack_require__(2).property;

		function Paginator(name, paginator) {
		  property(this, 'inputToken', paginator.input_token);
		  property(this, 'limitKey', paginator.limit_key);
		  property(this, 'moreResults', paginator.more_results);
		  property(this, 'outputToken', paginator.output_token);
		  property(this, 'resultKey', paginator.result_key);
		}

		/**
		 * @api private
		 */
		module.exports = Paginator;


	/***/ }),
	/* 37 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var property = util.property;

		function ResourceWaiter(name, waiter, options) {
		  options = options || {};
		  property(this, 'name', name);
		  property(this, 'api', options.api, false);

		  if (waiter.operation) {
		    property(this, 'operation', util.string.lowerFirst(waiter.operation));
		  }

		  var self = this;
		  var keys = [
		    'type',
		    'description',
		    'delay',
		    'maxAttempts',
		    'acceptors'
		  ];

		  keys.forEach(function(key) {
		    var value = waiter[key];
		    if (value) {
		      property(self, key, value);
		    }
		  });
		}

		/**
		 * @api private
		 */
		module.exports = ResourceWaiter;


	/***/ }),
	/* 38 */
	/***/ (function(module, exports) {

		function apiLoader(svc, version) {
		  if (!apiLoader.services.hasOwnProperty(svc)) {
		    throw new Error('InvalidService: Failed to load api for ' + svc);
		  }
		  return apiLoader.services[svc][version];
		}

		/**
		 * @api private
		 *
		 * This member of AWS.apiLoader is private, but changing it will necessitate a
		 * change to ../scripts/services-table-generator.ts
		 */
		apiLoader.services = {};

		/**
		 * @api private
		 */
		module.exports = apiLoader;


	/***/ }),
	/* 39 */
	/***/ (function(module, exports, __webpack_require__) {

		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		var LRU_1 = __webpack_require__(40);
		var CACHE_SIZE = 1000;
		/**
		 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
		 */
		var EndpointCache = /** @class */ (function () {
		    function EndpointCache(maxSize) {
		        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
		        this.maxSize = maxSize;
		        this.cache = new LRU_1.LRUCache(maxSize);
		    }
		    ;
		    Object.defineProperty(EndpointCache.prototype, "size", {
		        get: function () {
		            return this.cache.length;
		        },
		        enumerable: true,
		        configurable: true
		    });
		    EndpointCache.prototype.put = function (key, value) {
		      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
		        var endpointRecord = this.populateValue(value);
		        this.cache.put(keyString, endpointRecord);
		    };
		    EndpointCache.prototype.get = function (key) {
		      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
		        var now = Date.now();
		        var records = this.cache.get(keyString);
		        if (records) {
		            for (var i = records.length-1; i >= 0; i--) {
		                var record = records[i];
		                if (record.Expire < now) {
		                    records.splice(i, 1);
		                }
		            }
		            if (records.length === 0) {
		                this.cache.remove(keyString);
		                return undefined;
		            }
		        }
		        return records;
		    };
		    EndpointCache.getKeyString = function (key) {
		        var identifiers = [];
		        var identifierNames = Object.keys(key).sort();
		        for (var i = 0; i < identifierNames.length; i++) {
		            var identifierName = identifierNames[i];
		            if (key[identifierName] === undefined)
		                continue;
		            identifiers.push(key[identifierName]);
		        }
		        return identifiers.join(' ');
		    };
		    EndpointCache.prototype.populateValue = function (endpoints) {
		        var now = Date.now();
		        return endpoints.map(function (endpoint) { return ({
		            Address: endpoint.Address || '',
		            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
		        }); });
		    };
		    EndpointCache.prototype.empty = function () {
		        this.cache.empty();
		    };
		    EndpointCache.prototype.remove = function (key) {
		      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
		        this.cache.remove(keyString);
		    };
		    return EndpointCache;
		}());
		exports.EndpointCache = EndpointCache;

	/***/ }),
	/* 40 */
	/***/ (function(module, exports) {

		"use strict";
		Object.defineProperty(exports, "__esModule", { value: true });
		var LinkedListNode = /** @class */ (function () {
		    function LinkedListNode(key, value) {
		        this.key = key;
		        this.value = value;
		    }
		    return LinkedListNode;
		}());
		var LRUCache = /** @class */ (function () {
		    function LRUCache(size) {
		        this.nodeMap = {};
		        this.size = 0;
		        if (typeof size !== 'number' || size < 1) {
		            throw new Error('Cache size can only be positive number');
		        }
		        this.sizeLimit = size;
		    }
		    Object.defineProperty(LRUCache.prototype, "length", {
		        get: function () {
		            return this.size;
		        },
		        enumerable: true,
		        configurable: true
		    });
		    LRUCache.prototype.prependToList = function (node) {
		        if (!this.headerNode) {
		            this.tailNode = node;
		        }
		        else {
		            this.headerNode.prev = node;
		            node.next = this.headerNode;
		        }
		        this.headerNode = node;
		        this.size++;
		    };
		    LRUCache.prototype.removeFromTail = function () {
		        if (!this.tailNode) {
		            return undefined;
		        }
		        var node = this.tailNode;
		        var prevNode = node.prev;
		        if (prevNode) {
		            prevNode.next = undefined;
		        }
		        node.prev = undefined;
		        this.tailNode = prevNode;
		        this.size--;
		        return node;
		    };
		    LRUCache.prototype.detachFromList = function (node) {
		        if (this.headerNode === node) {
		            this.headerNode = node.next;
		        }
		        if (this.tailNode === node) {
		            this.tailNode = node.prev;
		        }
		        if (node.prev) {
		            node.prev.next = node.next;
		        }
		        if (node.next) {
		            node.next.prev = node.prev;
		        }
		        node.next = undefined;
		        node.prev = undefined;
		        this.size--;
		    };
		    LRUCache.prototype.get = function (key) {
		        if (this.nodeMap[key]) {
		            var node = this.nodeMap[key];
		            this.detachFromList(node);
		            this.prependToList(node);
		            return node.value;
		        }
		    };
		    LRUCache.prototype.remove = function (key) {
		        if (this.nodeMap[key]) {
		            var node = this.nodeMap[key];
		            this.detachFromList(node);
		            delete this.nodeMap[key];
		        }
		    };
		    LRUCache.prototype.put = function (key, value) {
		        if (this.nodeMap[key]) {
		            this.remove(key);
		        }
		        else if (this.size === this.sizeLimit) {
		            var tailNode = this.removeFromTail();
		            var key_1 = tailNode.key;
		            delete this.nodeMap[key_1];
		        }
		        var newNode = new LinkedListNode(key, value);
		        this.nodeMap[key] = newNode;
		        this.prependToList(newNode);
		    };
		    LRUCache.prototype.empty = function () {
		        var keys = Object.keys(this.nodeMap);
		        for (var i = 0; i < keys.length; i++) {
		            var key = keys[i];
		            var node = this.nodeMap[key];
		            this.detachFromList(node);
		            delete this.nodeMap[key];
		        }
		    };
		    return LRUCache;
		}());
		exports.LRUCache = LRUCache;

	/***/ }),
	/* 41 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);

		/**
		 * @api private
		 * @!method on(eventName, callback)
		 *   Registers an event listener callback for the event given by `eventName`.
		 *   Parameters passed to the callback function depend on the individual event
		 *   being triggered. See the event documentation for those parameters.
		 *
		 *   @param eventName [String] the event name to register the listener for
		 *   @param callback [Function] the listener callback function
		 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
		 *     Default to be false.
		 *   @return [AWS.SequentialExecutor] the same object for chaining
		 */
		AWS.SequentialExecutor = AWS.util.inherit({

		  constructor: function SequentialExecutor() {
		    this._events = {};
		  },

		  /**
		   * @api private
		   */
		  listeners: function listeners(eventName) {
		    return this._events[eventName] ? this._events[eventName].slice(0) : [];
		  },

		  on: function on(eventName, listener, toHead) {
		    if (this._events[eventName]) {
		      toHead ?
		        this._events[eventName].unshift(listener) :
		        this._events[eventName].push(listener);
		    } else {
		      this._events[eventName] = [listener];
		    }
		    return this;
		  },

		  onAsync: function onAsync(eventName, listener, toHead) {
		    listener._isAsync = true;
		    return this.on(eventName, listener, toHead);
		  },

		  removeListener: function removeListener(eventName, listener) {
		    var listeners = this._events[eventName];
		    if (listeners) {
		      var length = listeners.length;
		      var position = -1;
		      for (var i = 0; i < length; ++i) {
		        if (listeners[i] === listener) {
		          position = i;
		        }
		      }
		      if (position > -1) {
		        listeners.splice(position, 1);
		      }
		    }
		    return this;
		  },

		  removeAllListeners: function removeAllListeners(eventName) {
		    if (eventName) {
		      delete this._events[eventName];
		    } else {
		      this._events = {};
		    }
		    return this;
		  },

		  /**
		   * @api private
		   */
		  emit: function emit(eventName, eventArgs, doneCallback) {
		    if (!doneCallback) doneCallback = function() { };
		    var listeners = this.listeners(eventName);
		    var count = listeners.length;
		    this.callListeners(listeners, eventArgs, doneCallback);
		    return count > 0;
		  },

		  /**
		   * @api private
		   */
		  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
		    var self = this;
		    var error = prevError || null;

		    function callNextListener(err) {
		      if (err) {
		        error = AWS.util.error(error || new Error(), err);
		        if (self._haltHandlersOnError) {
		          return doneCallback.call(self, error);
		        }
		      }
		      self.callListeners(listeners, args, doneCallback, error);
		    }

		    while (listeners.length > 0) {
		      var listener = listeners.shift();
		      if (listener._isAsync) { // asynchronous listener
		        listener.apply(self, args.concat([callNextListener]));
		        return; // stop here, callNextListener will continue
		      } else { // synchronous listener
		        try {
		          listener.apply(self, args);
		        } catch (err) {
		          error = AWS.util.error(error || new Error(), err);
		        }
		        if (error && self._haltHandlersOnError) {
		          doneCallback.call(self, error);
		          return;
		        }
		      }
		    }
		    doneCallback.call(self, error);
		  },

		  /**
		   * Adds or copies a set of listeners from another list of
		   * listeners or SequentialExecutor object.
		   *
		   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
		   *   a list of events and callbacks, or an event emitter object
		   *   containing listeners to add to this emitter object.
		   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
		   * @example Adding listeners from a map of listeners
		   *   emitter.addListeners({
		   *     event1: [function() { ... }, function() { ... }],
		   *     event2: [function() { ... }]
		   *   });
		   *   emitter.emit('event1'); // emitter has event1
		   *   emitter.emit('event2'); // emitter has event2
		   * @example Adding listeners from another emitter object
		   *   var emitter1 = new AWS.SequentialExecutor();
		   *   emitter1.on('event1', function() { ... });
		   *   emitter1.on('event2', function() { ... });
		   *   var emitter2 = new AWS.SequentialExecutor();
		   *   emitter2.addListeners(emitter1);
		   *   emitter2.emit('event1'); // emitter2 has event1
		   *   emitter2.emit('event2'); // emitter2 has event2
		   */
		  addListeners: function addListeners(listeners) {
		    var self = this;

		    // extract listeners if parameter is an SequentialExecutor object
		    if (listeners._events) listeners = listeners._events;

		    AWS.util.each(listeners, function(event, callbacks) {
		      if (typeof callbacks === 'function') callbacks = [callbacks];
		      AWS.util.arrayEach(callbacks, function(callback) {
		        self.on(event, callback);
		      });
		    });

		    return self;
		  },

		  /**
		   * Registers an event with {on} and saves the callback handle function
		   * as a property on the emitter object using a given `name`.
		   *
		   * @param name [String] the property name to set on this object containing
		   *   the callback function handle so that the listener can be removed in
		   *   the future.
		   * @param (see on)
		   * @return (see on)
		   * @example Adding a named listener DATA_CALLBACK
		   *   var listener = function() { doSomething(); };
		   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
		   *
		   *   // the following prints: true
		   *   console.log(emitter.DATA_CALLBACK == listener);
		   */
		  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
		    this[name] = callback;
		    this.addListener(eventName, callback, toHead);
		    return this;
		  },

		  /**
		   * @api private
		   */
		  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
		    callback._isAsync = true;
		    return this.addNamedListener(name, eventName, callback, toHead);
		  },

		  /**
		   * Helper method to add a set of named listeners using
		   * {addNamedListener}. The callback contains a parameter
		   * with a handle to the `addNamedListener` method.
		   *
		   * @callback callback function(add)
		   *   The callback function is called immediately in order to provide
		   *   the `add` function to the block. This simplifies the addition of
		   *   a large group of named listeners.
		   *   @param add [Function] the {addNamedListener} function to call
		   *     when registering listeners.
		   * @example Adding a set of named listeners
		   *   emitter.addNamedListeners(function(add) {
		   *     add('DATA_CALLBACK', 'data', function() { ... });
		   *     add('OTHER', 'otherEvent', function() { ... });
		   *     add('LAST', 'lastEvent', function() { ... });
		   *   });
		   *
		   *   // these properties are now set:
		   *   emitter.DATA_CALLBACK;
		   *   emitter.OTHER;
		   *   emitter.LAST;
		   */
		  addNamedListeners: function addNamedListeners(callback) {
		    var self = this;
		    callback(
		      function() {
		        self.addNamedListener.apply(self, arguments);
		      },
		      function() {
		        self.addNamedAsyncListener.apply(self, arguments);
		      }
		    );
		    return this;
		  }
		});

		/**
		 * {on} is the prefered method.
		 * @api private
		 */
		AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

		/**
		 * @api private
		 */
		module.exports = AWS.SequentialExecutor;


	/***/ }),
	/* 42 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {var AWS = __webpack_require__(1);
		var Api = __webpack_require__(34);
		var regionConfig = __webpack_require__(43);

		var inherit = AWS.util.inherit;
		var clientCount = 0;
		var region_utils = __webpack_require__(45);

		/**
		 * The service class representing an AWS service.
		 *
		 * @class_abstract This class is an abstract class.
		 *
		 * @!attribute apiVersions
		 *   @return [Array<String>] the list of API versions supported by this service.
		 *   @readonly
		 */
		AWS.Service = inherit({
		  /**
		   * Create a new service object with a configuration object
		   *
		   * @param config [map] a map of configuration options
		   */
		  constructor: function Service(config) {
		    if (!this.loadServiceClass) {
		      throw AWS.util.error(new Error(),
		        'Service must be constructed with `new\' operator');
		    }

		    if (config) {
		      if (config.region) {
		        var region = config.region;
		        if (region_utils.isFipsRegion(region)) {
		          config.region = region_utils.getRealRegion(region);
		          config.useFipsEndpoint = true;
		        }
		        if (region_utils.isGlobalRegion(region)) {
		          config.region = region_utils.getRealRegion(region);
		        }
		      }
		      if (typeof config.useDualstack === 'boolean'
		        && typeof config.useDualstackEndpoint !== 'boolean') {
		        config.useDualstackEndpoint = config.useDualstack;
		      }
		    }

		    var ServiceClass = this.loadServiceClass(config || {});
		    if (ServiceClass) {
		      var originalConfig = AWS.util.copy(config);
		      var svc = new ServiceClass(config);
		      Object.defineProperty(svc, '_originalConfig', {
		        get: function() { return originalConfig; },
		        enumerable: false,
		        configurable: true
		      });
		      svc._clientId = ++clientCount;
		      return svc;
		    }
		    this.initialize(config);
		  },

		  /**
		   * @api private
		   */
		  initialize: function initialize(config) {
		    var svcConfig = AWS.config[this.serviceIdentifier];
		    this.config = new AWS.Config(AWS.config);
		    if (svcConfig) this.config.update(svcConfig, true);
		    if (config) this.config.update(config, true);

		    this.validateService();
		    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

		    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
		    this.setEndpoint(this.config.endpoint);
		    //enable attaching listeners to service client
		    AWS.SequentialExecutor.call(this);
		    AWS.Service.addDefaultMonitoringListeners(this);
		    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
		      var publisher = this.publisher;
		      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
		        process.nextTick(function() {publisher.eventHandler(event);});
		      });
		      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
		        process.nextTick(function() {publisher.eventHandler(event);});
		      });
		    }
		  },

		  /**
		   * @api private
		   */
		  validateService: function validateService() {
		  },

		  /**
		   * @api private
		   */
		  loadServiceClass: function loadServiceClass(serviceConfig) {
		    var config = serviceConfig;
		    if (!AWS.util.isEmpty(this.api)) {
		      return null;
		    } else if (config.apiConfig) {
		      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
		    } else if (!this.constructor.services) {
		      return null;
		    } else {
		      config = new AWS.Config(AWS.config);
		      config.update(serviceConfig, true);
		      var version = config.apiVersions[this.constructor.serviceIdentifier];
		      version = version || config.apiVersion;
		      return this.getLatestServiceClass(version);
		    }
		  },

		  /**
		   * @api private
		   */
		  getLatestServiceClass: function getLatestServiceClass(version) {
		    version = this.getLatestServiceVersion(version);
		    if (this.constructor.services[version] === null) {
		      AWS.Service.defineServiceApi(this.constructor, version);
		    }

		    return this.constructor.services[version];
		  },

		  /**
		   * @api private
		   */
		  getLatestServiceVersion: function getLatestServiceVersion(version) {
		    if (!this.constructor.services || this.constructor.services.length === 0) {
		      throw new Error('No services defined on ' +
		                      this.constructor.serviceIdentifier);
		    }

		    if (!version) {
		      version = 'latest';
		    } else if (AWS.util.isType(version, Date)) {
		      version = AWS.util.date.iso8601(version).split('T')[0];
		    }

		    if (Object.hasOwnProperty(this.constructor.services, version)) {
		      return version;
		    }

		    var keys = Object.keys(this.constructor.services).sort();
		    var selectedVersion = null;
		    for (var i = keys.length - 1; i >= 0; i--) {
		      // versions that end in "*" are not available on disk and can be
		      // skipped, so do not choose these as selectedVersions
		      if (keys[i][keys[i].length - 1] !== '*') {
		        selectedVersion = keys[i];
		      }
		      if (keys[i].substr(0, 10) <= version) {
		        return selectedVersion;
		      }
		    }

		    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
		                    ' API to satisfy version constraint `' + version + '\'');
		  },

		  /**
		   * @api private
		   */
		  api: {},

		  /**
		   * @api private
		   */
		  defaultRetryCount: 3,

		  /**
		   * @api private
		   */
		  customizeRequests: function customizeRequests(callback) {
		    if (!callback) {
		      this.customRequestHandler = null;
		    } else if (typeof callback === 'function') {
		      this.customRequestHandler = callback;
		    } else {
		      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
		    }
		  },

		  /**
		   * Calls an operation on a service with the given input parameters.
		   *
		   * @param operation [String] the name of the operation to call on the service.
		   * @param params [map] a map of input options for the operation
		   * @callback callback function(err, data)
		   *   If a callback is supplied, it is called when a response is returned
		   *   from the service.
		   *   @param err [Error] the error object returned from the request.
		   *     Set to `null` if the request is successful.
		   *   @param data [Object] the de-serialized data returned from
		   *     the request. Set to `null` if a request error occurs.
		   */
		  makeRequest: function makeRequest(operation, params, callback) {
		    if (typeof params === 'function') {
		      callback = params;
		      params = null;
		    }

		    params = params || {};
		    if (this.config.params) { // copy only toplevel bound params
		      var rules = this.api.operations[operation];
		      if (rules) {
		        params = AWS.util.copy(params);
		        AWS.util.each(this.config.params, function(key, value) {
		          if (rules.input.members[key]) {
		            if (params[key] === undefined || params[key] === null) {
		              params[key] = value;
		            }
		          }
		        });
		      }
		    }

		    var request = new AWS.Request(this, operation, params);
		    this.addAllRequestListeners(request);
		    this.attachMonitoringEmitter(request);
		    if (callback) request.send(callback);
		    return request;
		  },

		  /**
		   * Calls an operation on a service with the given input parameters, without
		   * any authentication data. This method is useful for "public" API operations.
		   *
		   * @param operation [String] the name of the operation to call on the service.
		   * @param params [map] a map of input options for the operation
		   * @callback callback function(err, data)
		   *   If a callback is supplied, it is called when a response is returned
		   *   from the service.
		   *   @param err [Error] the error object returned from the request.
		   *     Set to `null` if the request is successful.
		   *   @param data [Object] the de-serialized data returned from
		   *     the request. Set to `null` if a request error occurs.
		   */
		  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
		    if (typeof params === 'function') {
		      callback = params;
		      params = {};
		    }

		    var request = this.makeRequest(operation, params).toUnauthenticated();
		    return callback ? request.send(callback) : request;
		  },

		  /**
		   * Waits for a given state
		   *
		   * @param state [String] the state on the service to wait for
		   * @param params [map] a map of parameters to pass with each request
		   * @option params $waiter [map] a map of configuration options for the waiter
		   * @option params $waiter.delay [Number] The number of seconds to wait between
		   *                                       requests
		   * @option params $waiter.maxAttempts [Number] The maximum number of requests
		   *                                             to send while waiting
		   * @callback callback function(err, data)
		   *   If a callback is supplied, it is called when a response is returned
		   *   from the service.
		   *   @param err [Error] the error object returned from the request.
		   *     Set to `null` if the request is successful.
		   *   @param data [Object] the de-serialized data returned from
		   *     the request. Set to `null` if a request error occurs.
		   */
		  waitFor: function waitFor(state, params, callback) {
		    var waiter = new AWS.ResourceWaiter(this, state);
		    return waiter.wait(params, callback);
		  },

		  /**
		   * @api private
		   */
		  addAllRequestListeners: function addAllRequestListeners(request) {
		    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
		                AWS.EventListeners.CorePost];
		    for (var i = 0; i < list.length; i++) {
		      if (list[i]) request.addListeners(list[i]);
		    }

		    // disable parameter validation
		    if (!this.config.paramValidation) {
		      request.removeListener('validate',
		        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
		    }

		    if (this.config.logger) { // add logging events
		      request.addListeners(AWS.EventListeners.Logger);
		    }

		    this.setupRequestListeners(request);
		    // call prototype's customRequestHandler
		    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
		      this.constructor.prototype.customRequestHandler(request);
		    }
		    // call instance's customRequestHandler
		    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
		      this.customRequestHandler(request);
		    }
		  },

		  /**
		   * Event recording metrics for a whole API call.
		   * @returns {object} a subset of api call metrics
		   * @api private
		   */
		  apiCallEvent: function apiCallEvent(request) {
		    var api = request.service.api.operations[request.operation];
		    var monitoringEvent = {
		      Type: 'ApiCall',
		      Api: api ? api.name : request.operation,
		      Version: 1,
		      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
		      Region: request.httpRequest.region,
		      MaxRetriesExceeded: 0,
		      UserAgent: request.httpRequest.getUserAgent(),
		    };
		    var response = request.response;
		    if (response.httpResponse.statusCode) {
		      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
		    }
		    if (response.error) {
		      var error = response.error;
		      var statusCode = response.httpResponse.statusCode;
		      if (statusCode > 299) {
		        if (error.code) monitoringEvent.FinalAwsException = error.code;
		        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
		      } else {
		        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
		        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
		      }
		    }
		    return monitoringEvent;
		  },

		  /**
		   * Event recording metrics for an API call attempt.
		   * @returns {object} a subset of api call attempt metrics
		   * @api private
		   */
		  apiAttemptEvent: function apiAttemptEvent(request) {
		    var api = request.service.api.operations[request.operation];
		    var monitoringEvent = {
		      Type: 'ApiCallAttempt',
		      Api: api ? api.name : request.operation,
		      Version: 1,
		      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
		      Fqdn: request.httpRequest.endpoint.hostname,
		      UserAgent: request.httpRequest.getUserAgent(),
		    };
		    var response = request.response;
		    if (response.httpResponse.statusCode) {
		      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
		    }
		    if (
		      !request._unAuthenticated &&
		      request.service.config.credentials &&
		      request.service.config.credentials.accessKeyId
		    ) {
		      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
		    }
		    if (!response.httpResponse.headers) return monitoringEvent;
		    if (request.httpRequest.headers['x-amz-security-token']) {
		      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
		    }
		    if (response.httpResponse.headers['x-amzn-requestid']) {
		      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
		    }
		    if (response.httpResponse.headers['x-amz-request-id']) {
		      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
		    }
		    if (response.httpResponse.headers['x-amz-id-2']) {
		      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
		    }
		    return monitoringEvent;
		  },

		  /**
		   * Add metrics of failed request.
		   * @api private
		   */
		  attemptFailEvent: function attemptFailEvent(request) {
		    var monitoringEvent = this.apiAttemptEvent(request);
		    var response = request.response;
		    var error = response.error;
		    if (response.httpResponse.statusCode > 299 ) {
		      if (error.code) monitoringEvent.AwsException = error.code;
		      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
		    } else {
		      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
		      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
		    }
		    return monitoringEvent;
		  },

		  /**
		   * Attach listeners to request object to fetch metrics of each request
		   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
		   * @api private
		   */
		  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
		    var attemptTimestamp; //timestamp marking the beginning of a request attempt
		    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
		    var attemptLatency; //latency from request sent out to http response reaching SDK
		    var callStartRealTime; //Start time of API call. Used to calculating API call latency
		    var attemptCount = 0; //request.retryCount is not reliable here
		    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
		    var callTimestamp; //timestamp when the request is created
		    var self = this;
		    var addToHead = true;

		    request.on('validate', function () {
		      callStartRealTime = AWS.util.realClock.now();
		      callTimestamp = Date.now();
		    }, addToHead);
		    request.on('sign', function () {
		      attemptStartRealTime = AWS.util.realClock.now();
		      attemptTimestamp = Date.now();
		      region = request.httpRequest.region;
		      attemptCount++;
		    }, addToHead);
		    request.on('validateResponse', function() {
		      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
		    });
		    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
		      var apiAttemptEvent = self.apiAttemptEvent(request);
		      apiAttemptEvent.Timestamp = attemptTimestamp;
		      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
		      apiAttemptEvent.Region = region;
		      self.emit('apiCallAttempt', [apiAttemptEvent]);
		    });
		    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
		      var apiAttemptEvent = self.attemptFailEvent(request);
		      apiAttemptEvent.Timestamp = attemptTimestamp;
		      //attemptLatency may not be available if fail before response
		      attemptLatency = attemptLatency ||
		        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
		      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
		      apiAttemptEvent.Region = region;
		      self.emit('apiCallAttempt', [apiAttemptEvent]);
		    });
		    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
		      var apiCallEvent = self.apiCallEvent(request);
		      apiCallEvent.AttemptCount = attemptCount;
		      if (apiCallEvent.AttemptCount <= 0) return;
		      apiCallEvent.Timestamp = callTimestamp;
		      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
		      apiCallEvent.Latency = latency >= 0 ? latency : 0;
		      var response = request.response;
		      if (
		        response.error &&
		        response.error.retryable &&
		        typeof response.retryCount === 'number' &&
		        typeof response.maxRetries === 'number' &&
		        (response.retryCount >= response.maxRetries)
		      ) {
		        apiCallEvent.MaxRetriesExceeded = 1;
		      }
		      self.emit('apiCall', [apiCallEvent]);
		    });
		  },

		  /**
		   * Override this method to setup any custom request listeners for each
		   * new request to the service.
		   *
		   * @method_abstract This is an abstract method.
		   */
		  setupRequestListeners: function setupRequestListeners(request) {
		  },

		  /**
		   * Gets the signing name for a given request
		   * @api private
		   */
		  getSigningName: function getSigningName() {
		    return this.api.signingName || this.api.endpointPrefix;
		  },

		  /**
		   * Gets the signer class for a given request
		   * @api private
		   */
		  getSignerClass: function getSignerClass(request) {
		    var version;
		    // get operation authtype if present
		    var operation = null;
		    var authtype = '';
		    if (request) {
		      var operations = request.service.api.operations || {};
		      operation = operations[request.operation] || null;
		      authtype = operation ? operation.authtype : '';
		    }
		    if (this.config.signatureVersion) {
		      version = this.config.signatureVersion;
		    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
		      version = 'v4';
		    } else if (authtype === 'bearer') {
		      version = 'bearer';
		    } else {
		      version = this.api.signatureVersion;
		    }
		    return AWS.Signers.RequestSigner.getVersion(version);
		  },

		  /**
		   * @api private
		   */
		  serviceInterface: function serviceInterface() {
		    switch (this.api.protocol) {
		      case 'ec2': return AWS.EventListeners.Query;
		      case 'query': return AWS.EventListeners.Query;
		      case 'json': return AWS.EventListeners.Json;
		      case 'rest-json': return AWS.EventListeners.RestJson;
		      case 'rest-xml': return AWS.EventListeners.RestXml;
		    }
		    if (this.api.protocol) {
		      throw new Error('Invalid service `protocol\' ' +
		        this.api.protocol + ' in API config');
		    }
		  },

		  /**
		   * @api private
		   */
		  successfulResponse: function successfulResponse(resp) {
		    return resp.httpResponse.statusCode < 300;
		  },

		  /**
		   * How many times a failed request should be retried before giving up.
		   * the defaultRetryCount can be overriden by service classes.
		   *
		   * @api private
		   */
		  numRetries: function numRetries() {
		    if (this.config.maxRetries !== undefined) {
		      return this.config.maxRetries;
		    } else {
		      return this.defaultRetryCount;
		    }
		  },

		  /**
		   * @api private
		   */
		  retryDelays: function retryDelays(retryCount, err) {
		    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
		  },

		  /**
		   * @api private
		   */
		  retryableError: function retryableError(error) {
		    if (this.timeoutError(error)) return true;
		    if (this.networkingError(error)) return true;
		    if (this.expiredCredentialsError(error)) return true;
		    if (this.throttledError(error)) return true;
		    if (error.statusCode >= 500) return true;
		    return false;
		  },

		  /**
		   * @api private
		   */
		  networkingError: function networkingError(error) {
		    return error.code === 'NetworkingError';
		  },

		  /**
		   * @api private
		   */
		  timeoutError: function timeoutError(error) {
		    return error.code === 'TimeoutError';
		  },

		  /**
		   * @api private
		   */
		  expiredCredentialsError: function expiredCredentialsError(error) {
		    // TODO : this only handles *one* of the expired credential codes
		    return (error.code === 'ExpiredTokenException');
		  },

		  /**
		   * @api private
		   */
		  clockSkewError: function clockSkewError(error) {
		    switch (error.code) {
		      case 'RequestTimeTooSkewed':
		      case 'RequestExpired':
		      case 'InvalidSignatureException':
		      case 'SignatureDoesNotMatch':
		      case 'AuthFailure':
		      case 'RequestInTheFuture':
		        return true;
		      default: return false;
		    }
		  },

		  /**
		   * @api private
		   */
		  getSkewCorrectedDate: function getSkewCorrectedDate() {
		    return new Date(Date.now() + this.config.systemClockOffset);
		  },

		  /**
		   * @api private
		   */
		  applyClockOffset: function applyClockOffset(newServerTime) {
		    if (newServerTime) {
		      this.config.systemClockOffset = newServerTime - Date.now();
		    }
		  },

		  /**
		   * @api private
		   */
		  isClockSkewed: function isClockSkewed(newServerTime) {
		    if (newServerTime) {
		      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
		    }
		  },

		  /**
		   * @api private
		   */
		  throttledError: function throttledError(error) {
		    // this logic varies between services
		    if (error.statusCode === 429) return true;
		    switch (error.code) {
		      case 'ProvisionedThroughputExceededException':
		      case 'Throttling':
		      case 'ThrottlingException':
		      case 'RequestLimitExceeded':
		      case 'RequestThrottled':
		      case 'RequestThrottledException':
		      case 'TooManyRequestsException':
		      case 'TransactionInProgressException': //dynamodb
		      case 'EC2ThrottledException':
		        return true;
		      default:
		        return false;
		    }
		  },

		  /**
		   * @api private
		   */
		  endpointFromTemplate: function endpointFromTemplate(endpoint) {
		    if (typeof endpoint !== 'string') return endpoint;

		    var e = endpoint;
		    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
		    e = e.replace(/\{region\}/g, this.config.region);
		    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
		    return e;
		  },

		  /**
		   * @api private
		   */
		  setEndpoint: function setEndpoint(endpoint) {
		    this.endpoint = new AWS.Endpoint(endpoint, this.config);
		  },

		  /**
		   * @api private
		   */
		  paginationConfig: function paginationConfig(operation, throwException) {
		    var paginator = this.api.operations[operation].paginator;
		    if (!paginator) {
		      if (throwException) {
		        var e = new Error();
		        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
		      }
		      return null;
		    }

		    return paginator;
		  }
		});

		AWS.util.update(AWS.Service, {

		  /**
		   * Adds one method for each operation described in the api configuration
		   *
		   * @api private
		   */
		  defineMethods: function defineMethods(svc) {
		    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
		      if (svc.prototype[method]) return;
		      var operation = svc.prototype.api.operations[method];
		      if (operation.authtype === 'none') {
		        svc.prototype[method] = function (params, callback) {
		          return this.makeUnauthenticatedRequest(method, params, callback);
		        };
		      } else {
		        svc.prototype[method] = function (params, callback) {
		          return this.makeRequest(method, params, callback);
		        };
		      }
		    });
		  },

		  /**
		   * Defines a new Service class using a service identifier and list of versions
		   * including an optional set of features (functions) to apply to the class
		   * prototype.
		   *
		   * @param serviceIdentifier [String] the identifier for the service
		   * @param versions [Array<String>] a list of versions that work with this
		   *   service
		   * @param features [Object] an object to attach to the prototype
		   * @return [Class<Service>] the service class defined by this function.
		   */
		  defineService: function defineService(serviceIdentifier, versions, features) {
		    AWS.Service._serviceMap[serviceIdentifier] = true;
		    if (!Array.isArray(versions)) {
		      features = versions;
		      versions = [];
		    }

		    var svc = inherit(AWS.Service, features || {});

		    if (typeof serviceIdentifier === 'string') {
		      AWS.Service.addVersions(svc, versions);

		      var identifier = svc.serviceIdentifier || serviceIdentifier;
		      svc.serviceIdentifier = identifier;
		    } else { // defineService called with an API
		      svc.prototype.api = serviceIdentifier;
		      AWS.Service.defineMethods(svc);
		    }
		    AWS.SequentialExecutor.call(this.prototype);
		    //util.clientSideMonitoring is only available in node
		    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
		      var Publisher = AWS.util.clientSideMonitoring.Publisher;
		      var configProvider = AWS.util.clientSideMonitoring.configProvider;
		      var publisherConfig = configProvider();
		      this.prototype.publisher = new Publisher(publisherConfig);
		      if (publisherConfig.enabled) {
		        //if csm is enabled in environment, SDK should send all metrics
		        AWS.Service._clientSideMonitoring = true;
		      }
		    }
		    AWS.SequentialExecutor.call(svc.prototype);
		    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
		    return svc;
		  },

		  /**
		   * @api private
		   */
		  addVersions: function addVersions(svc, versions) {
		    if (!Array.isArray(versions)) versions = [versions];

		    svc.services = svc.services || {};
		    for (var i = 0; i < versions.length; i++) {
		      if (svc.services[versions[i]] === undefined) {
		        svc.services[versions[i]] = null;
		      }
		    }

		    svc.apiVersions = Object.keys(svc.services).sort();
		  },

		  /**
		   * @api private
		   */
		  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
		    var svc = inherit(superclass, {
		      serviceIdentifier: superclass.serviceIdentifier
		    });

		    function setApi(api) {
		      if (api.isApi) {
		        svc.prototype.api = api;
		      } else {
		        svc.prototype.api = new Api(api, {
		          serviceIdentifier: superclass.serviceIdentifier
		        });
		      }
		    }

		    if (typeof version === 'string') {
		      if (apiConfig) {
		        setApi(apiConfig);
		      } else {
		        try {
		          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
		        } catch (err) {
		          throw AWS.util.error(err, {
		            message: 'Could not find API configuration ' +
		              superclass.serviceIdentifier + '-' + version
		          });
		        }
		      }
		      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
		        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
		      }
		      superclass.services[version] = svc;
		    } else {
		      setApi(version);
		    }

		    AWS.Service.defineMethods(svc);
		    return svc;
		  },

		  /**
		   * @api private
		   */
		  hasService: function(identifier) {
		    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
		  },

		  /**
		   * @param attachOn attach default monitoring listeners to object
		   *
		   * Each monitoring event should be emitted from service client to service constructor prototype and then
		   * to global service prototype like bubbling up. These default monitoring events listener will transfer
		   * the monitoring events to the upper layer.
		   * @api private
		   */
		  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
		    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
		      var baseClass = Object.getPrototypeOf(attachOn);
		      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
		    });
		    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
		      var baseClass = Object.getPrototypeOf(attachOn);
		      if (baseClass._events) baseClass.emit('apiCall', [event]);
		    });
		  },

		  /**
		   * @api private
		   */
		  _serviceMap: {}
		});

		AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

		/**
		 * @api private
		 */
		module.exports = AWS.Service;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

	/***/ }),
	/* 43 */
	/***/ (function(module, exports, __webpack_require__) {

		var util = __webpack_require__(2);
		var regionConfig = __webpack_require__(44);

		function generateRegionPrefix(region) {
		  if (!region) return null;
		  var parts = region.split('-');
		  if (parts.length < 3) return null;
		  return parts.slice(0, parts.length - 2).join('-') + '-*';
		}

		function derivedKeys(service) {
		  var region = service.config.region;
		  var regionPrefix = generateRegionPrefix(region);
		  var endpointPrefix = service.api.endpointPrefix;

		  return [
		    [region, endpointPrefix],
		    [regionPrefix, endpointPrefix],
		    [region, '*'],
		    [regionPrefix, '*'],
		    ['*', endpointPrefix],
		    ['*', '*']
		  ].map(function(item) {
		    return item[0] && item[1] ? item.join('/') : null;
		  });
		}

		function applyConfig(service, config) {
		  util.each(config, function(key, value) {
		    if (key === 'globalEndpoint') return;
		    if (service.config[key] === undefined || service.config[key] === null) {
		      service.config[key] = value;
		    }
		  });
		}

		function configureEndpoint(service) {
		  var keys = derivedKeys(service);
		  var useFipsEndpoint = service.config.useFipsEndpoint;
		  var useDualstackEndpoint = service.config.useDualstackEndpoint;
		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    if (!key) continue;

		    var rules = useFipsEndpoint
		      ? useDualstackEndpoint
		        ? regionConfig.dualstackFipsRules
		        : regionConfig.fipsRules
		      : useDualstackEndpoint
		      ? regionConfig.dualstackRules
		      : regionConfig.rules;

		    if (Object.prototype.hasOwnProperty.call(rules, key)) {
		      var config = rules[key];
		      if (typeof config === 'string') {
		        config = regionConfig.patterns[config];
		      }

		      // set global endpoint
		      service.isGlobalEndpoint = !!config.globalEndpoint;
		      if (config.signingRegion) {
		        service.signingRegion = config.signingRegion;
		      }

		      // signature version
		      if (!config.signatureVersion) config.signatureVersion = 'v4';

		      // merge config
		      applyConfig(service, config);
		      return;
		    }
		  }
		}

		function getEndpointSuffix(region) {
		  var regionRegexes = {
		    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
		    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
		    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
		    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
		    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
		  };
		  var defaultSuffix = 'amazonaws.com';
		  var regexes = Object.keys(regionRegexes);
		  for (var i = 0; i < regexes.length; i++) {
		    var regionPattern = RegExp(regexes[i]);
		    var dnsSuffix = regionRegexes[regexes[i]];
		    if (regionPattern.test(region)) return dnsSuffix;
		  }
		  return defaultSuffix;
		}

		/**
		 * @api private
		 */
		module.exports = {
		  configureEndpoint: configureEndpoint,
		  getEndpointSuffix: getEndpointSuffix,
		};


	/***/ }),
	/* 44 */
	/***/ (function(module, exports) {

		module.exports = {"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"us-iso-*/*":"usIso","us-isob-*/*":"usIsob","*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":"globalSSL","cn-*/route53":{"endpoint":"{service}.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-northwest-1"},"us-gov-*/route53":"globalGovCloud","us-iso-*/route53":{"endpoint":"{service}.c2s.ic.gov","globalEndpoint":true,"signingRegion":"us-iso-east-1"},"us-isob-*/route53":{"endpoint":"{service}.sc2s.sgov.gov","globalEndpoint":true,"signingRegion":"us-isob-east-1"},"*/waf":"globalSSL","*/iam":"globalSSL","cn-*/iam":{"endpoint":"{service}.cn-north-1.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-north-1"},"us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3signature","us-west-1/s3":"s3signature","us-west-2/s3":"s3signature","eu-west-1/s3":"s3signature","ap-southeast-1/s3":"s3signature","ap-southeast-2/s3":"s3signature","ap-northeast-1/s3":"s3signature","sa-east-1/s3":"s3signature","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"},"*/resource-explorer-2":"dualstackByDefault"},"fipsRules":{"*/*":"fipsStandard","us-gov-*/*":"fipsStandard","us-iso-*/*":{"endpoint":"{service}-fips.{region}.c2s.ic.gov"},"us-iso-*/dms":"usIso","us-isob-*/*":{"endpoint":"{service}-fips.{region}.sc2s.sgov.gov"},"us-isob-*/dms":"usIsob","cn-*/*":{"endpoint":"{service}-fips.{region}.amazonaws.com.cn"},"*/api.ecr":"fips.api.ecr","*/api.sagemaker":"fips.api.sagemaker","*/batch":"fipsDotPrefix","*/eks":"fipsDotPrefix","*/models.lex":"fips.models.lex","*/runtime.lex":"fips.runtime.lex","*/runtime.sagemaker":{"endpoint":"runtime-fips.sagemaker.{region}.amazonaws.com"},"*/iam":"fipsWithoutRegion","*/route53":"fipsWithoutRegion","*/transcribe":"fipsDotPrefix","*/waf":"fipsWithoutRegion","us-gov-*/transcribe":"fipsDotPrefix","us-gov-*/api.ecr":"fips.api.ecr","us-gov-*/api.sagemaker":"fips.api.sagemaker","us-gov-*/models.lex":"fips.models.lex","us-gov-*/runtime.lex":"fips.runtime.lex","us-gov-*/acm-pca":"fipsWithServiceOnly","us-gov-*/batch":"fipsWithServiceOnly","us-gov-*/config":"fipsWithServiceOnly","us-gov-*/eks":"fipsWithServiceOnly","us-gov-*/elasticmapreduce":"fipsWithServiceOnly","us-gov-*/identitystore":"fipsWithServiceOnly","us-gov-*/dynamodb":"fipsWithServiceOnly","us-gov-*/elasticloadbalancing":"fipsWithServiceOnly","us-gov-*/guardduty":"fipsWithServiceOnly","us-gov-*/monitoring":"fipsWithServiceOnly","us-gov-*/resource-groups":"fipsWithServiceOnly","us-gov-*/runtime.sagemaker":"fipsWithServiceOnly","us-gov-*/servicecatalog-appregistry":"fipsWithServiceOnly","us-gov-*/servicequotas":"fipsWithServiceOnly","us-gov-*/ssm":"fipsWithServiceOnly","us-gov-*/sts":"fipsWithServiceOnly","us-gov-*/support":"fipsWithServiceOnly","us-gov-west-1/states":"fipsWithServiceOnly","us-iso-east-1/elasticfilesystem":{"endpoint":"elasticfilesystem-fips.{region}.c2s.ic.gov"},"us-gov-west-1/organizations":"fipsWithServiceOnly","us-gov-west-1/route53":{"endpoint":"route53.us-gov.amazonaws.com"}},"dualstackRules":{"*/*":{"endpoint":"{service}.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackLegacy","cn-*/s3":"dualstackLegacyCn","*/s3-control":"dualstackLegacy","cn-*/s3-control":"dualstackLegacyCn","ap-south-1/ec2":"dualstackLegacyEc2","eu-west-1/ec2":"dualstackLegacyEc2","sa-east-1/ec2":"dualstackLegacyEc2","us-east-1/ec2":"dualstackLegacyEc2","us-east-2/ec2":"dualstackLegacyEc2","us-west-2/ec2":"dualstackLegacyEc2"},"dualstackFipsRules":{"*/*":{"endpoint":"{service}-fips.{region}.api.aws"},"cn-*/*":{"endpoint":"{service}-fips.{region}.api.amazonwebservices.com.cn"},"*/s3":"dualstackFipsLegacy","cn-*/s3":"dualstackFipsLegacyCn","*/s3-control":"dualstackFipsLegacy","cn-*/s3-control":"dualstackFipsLegacyCn"},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true,"signingRegion":"us-east-1"},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com","globalEndpoint":true,"signingRegion":"us-gov-west-1"},"s3signature":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"s3"},"usIso":{"endpoint":"{service}.{region}.c2s.ic.gov"},"usIsob":{"endpoint":"{service}.{region}.sc2s.sgov.gov"},"fipsStandard":{"endpoint":"{service}-fips.{region}.amazonaws.com"},"fipsDotPrefix":{"endpoint":"fips.{service}.{region}.amazonaws.com"},"fipsWithoutRegion":{"endpoint":"{service}-fips.amazonaws.com"},"fips.api.ecr":{"endpoint":"ecr-fips.{region}.amazonaws.com"},"fips.api.sagemaker":{"endpoint":"api-fips.sagemaker.{region}.amazonaws.com"},"fips.models.lex":{"endpoint":"models-fips.lex.{region}.amazonaws.com"},"fips.runtime.lex":{"endpoint":"runtime-fips.lex.{region}.amazonaws.com"},"fipsWithServiceOnly":{"endpoint":"{service}.{region}.amazonaws.com"},"dualstackLegacy":{"endpoint":"{service}.dualstack.{region}.amazonaws.com"},"dualstackLegacyCn":{"endpoint":"{service}.dualstack.{region}.amazonaws.com.cn"},"dualstackFipsLegacy":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com"},"dualstackFipsLegacyCn":{"endpoint":"{service}-fips.dualstack.{region}.amazonaws.com.cn"},"dualstackLegacyEc2":{"endpoint":"api.ec2.{region}.aws"},"dualstackByDefault":{"endpoint":"{service}.{region}.api.aws"}}}

	/***/ }),
	/* 45 */
	/***/ (function(module, exports) {

		function isFipsRegion(region) {
		  return typeof region === 'string' && (region.startsWith('fips-') || region.endsWith('-fips'));
		}

		function isGlobalRegion(region) {
		  return typeof region === 'string' && ['aws-global', 'aws-us-gov-global'].includes(region);
		}

		function getRealRegion(region) {
		  return ['fips-aws-global', 'aws-fips', 'aws-global'].includes(region)
		      ? 'us-east-1'
		      : ['fips-aws-us-gov-global', 'aws-us-gov-global'].includes(region)
		      ? 'us-gov-west-1'
		      : region.replace(/fips-(dkr-|prod-)?|-fips/, '');
		}

		module.exports = {
		  isFipsRegion: isFipsRegion,
		  isGlobalRegion: isGlobalRegion,
		  getRealRegion: getRealRegion
		};


	/***/ }),
	/* 46 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);
		__webpack_require__(47);
		__webpack_require__(48);
		var PromisesDependency;

		/**
		 * The main configuration class used by all service objects to set
		 * the region, credentials, and other options for requests.
		 *
		 * By default, credentials and region settings are left unconfigured.
		 * This should be configured by the application before using any
		 * AWS service APIs.
		 *
		 * In order to set global configuration options, properties should
		 * be assigned to the global {AWS.config} object.
		 *
		 * @see AWS.config
		 *
		 * @!group General Configuration Options
		 *
		 * @!attribute credentials
		 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
		 *
		 * @!attribute region
		 *   @example Set the global region setting to us-west-2
		 *     AWS.config.update({region: 'us-west-2'});
		 *   @return [AWS.Credentials] The region to send service requests to.
		 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
		 *     A list of available endpoints for each AWS service
		 *
		 * @!attribute maxRetries
		 *   @return [Integer] the maximum amount of retries to perform for a
		 *     service request. By default this value is calculated by the specific
		 *     service object that the request is being made to.
		 *
		 * @!attribute maxRedirects
		 *   @return [Integer] the maximum amount of redirects to follow for a
		 *     service request. Defaults to 10.
		 *
		 * @!attribute paramValidation
		 *   @return [Boolean|map] whether input parameters should be validated against
		 *     the operation description before sending the request. Defaults to true.
		 *     Pass a map to enable any of the following specific validation features:
		 *
		 *     * **min** [Boolean] &mdash; Validates that a value meets the min
		 *       constraint. This is enabled by default when paramValidation is set
		 *       to `true`.
		 *     * **max** [Boolean] &mdash; Validates that a value meets the max
		 *       constraint.
		 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
		 *       regular expression.
		 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
		 *       of the allowable enum values.
		 *
		 * @!attribute computeChecksums
		 *   @return [Boolean] whether to compute checksums for payload bodies when
		 *     the service accepts it (currently supported in S3 and SQS only).
		 *
		 * @!attribute convertResponseTypes
		 *   @return [Boolean] whether types are converted when parsing response data.
		 *     Currently only supported for JSON based services. Turning this off may
		 *     improve performance on large response payloads. Defaults to `true`.
		 *
		 * @!attribute correctClockSkew
		 *   @return [Boolean] whether to apply a clock skew correction and retry
		 *     requests that fail because of an skewed client clock. Defaults to
		 *     `false`.
		 *
		 * @!attribute sslEnabled
		 *   @return [Boolean] whether SSL is enabled for requests
		 *
		 * @!attribute s3ForcePathStyle
		 *   @return [Boolean] whether to force path style URLs for S3 objects
		 *
		 * @!attribute s3BucketEndpoint
		 *   @note Setting this configuration option requires an `endpoint` to be
		 *     provided explicitly to the service constructor.
		 *   @return [Boolean] whether the provided endpoint addresses an individual
		 *     bucket (false if it addresses the root API endpoint).
		 *
		 * @!attribute s3DisableBodySigning
		 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
		 *     Body signing can only be disabled when using https. Defaults to `true`.
		 *
		 * @!attribute s3UsEast1RegionalEndpoint
		 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
		 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
		 *     applicable to S3 client;
		 *     Defaults to 'legacy'
		 * @!attribute s3UseArnRegion
		 *   @return [Boolean] whether to override the request region with the region inferred
		 *     from requested resource's ARN. Only available for S3 buckets
		 *     Defaults to `true`
		 *
		 * @!attribute useAccelerateEndpoint
		 *   @note This configuration option is only compatible with S3 while accessing
		 *     dns-compatible buckets.
		 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
		 *     Defaults to `false`.
		 *
		 * @!attribute retryDelayOptions
		 *   @example Set the base retry delay for all services to 300 ms
		 *     AWS.config.update({retryDelayOptions: {base: 300}});
		 *     // Delays with maxRetries = 3: 300, 600, 1200
		 *   @example Set a custom backoff function to provide delay values on retries
		 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
		 *       // returns delay in ms
		 *     }}});
		 *   @return [map] A set of options to configure the retry delay on retryable errors.
		 *     Currently supported options are:
		 *
		 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
		 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
		 *       DynamoDB, where it defaults to 50ms.
		 *
		 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
		 *       retry count and error and returns the amount of time to delay in
		 *       milliseconds. If the result is a non-zero negative value, no further
		 *       retry attempts will be made. The `base` option will be ignored if this
		 *       option is supplied. The function is only called for retryable errors.
		 *
		 * @!attribute httpOptions
		 *   @return [map] A set of options to pass to the low-level HTTP request.
		 *     Currently supported options are:
		 *
		 *     * **proxy** [String] &mdash; the URL to proxy requests through
		 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
		 *       HTTP requests with. Used for connection pooling. Note that for
		 *       SSL connections, a special Agent object is used in order to enable
		 *       peer certificate verification. This feature is only supported in the
		 *       Node.js environment.
		 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
		 *       failing to establish a connection with the server after
		 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
		 *       connection has been established.
		 *     * **timeout** [Integer] &mdash; The number of milliseconds a request can
		 *       take before automatically being terminated.
		 *       Defaults to two minutes (120000).
		 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
		 *       HTTP requests. Used in the browser environment only. Set to false to
		 *       send requests synchronously. Defaults to true (async on).
		 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
		 *       property of an XMLHttpRequest object. Used in the browser environment
		 *       only. Defaults to false.
		 * @!attribute logger
		 *   @return [#write,#log] an object that responds to .write() (like a stream)
		 *     or .log() (like the console object) in order to log information about
		 *     requests
		 *
		 * @!attribute systemClockOffset
		 *   @return [Number] an offset value in milliseconds to apply to all signing
		 *     times. Use this to compensate for clock skew when your system may be
		 *     out of sync with the service time. Note that this configuration option
		 *     can only be applied to the global `AWS.config` object and cannot be
		 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
		 *
		 * @!attribute signatureVersion
		 *   @return [String] the signature version to sign requests with (overriding
		 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
		 *
		 * @!attribute signatureCache
		 *   @return [Boolean] whether the signature to sign requests with (overriding
		 *     the API configuration) is cached. Only applies to the signature version 'v4'.
		 *     Defaults to `true`.
		 *
		 * @!attribute endpointDiscoveryEnabled
		 *   @return [Boolean|undefined] whether to call operations with endpoints
		 *     given by service dynamically. Setting this config to `true` will enable
		 *     endpoint discovery for all applicable operations. Setting it to `false`
		 *     will explicitly disable endpoint discovery even though operations that
		 *     require endpoint discovery will presumably fail. Leaving it to
		 *     `undefined` means SDK only do endpoint discovery when it's required.
		 *     Defaults to `undefined`
		 *
		 * @!attribute endpointCacheSize
		 *   @return [Number] the size of the global cache storing endpoints from endpoint
		 *     discovery operations. Once endpoint cache is created, updating this setting
		 *     cannot change existing cache size.
		 *     Defaults to 1000
		 *
		 * @!attribute hostPrefixEnabled
		 *   @return [Boolean] whether to marshal request parameters to the prefix of
		 *     hostname. Defaults to `true`.
		 *
		 * @!attribute stsRegionalEndpoints
		 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
		 *     regional endpoints.
		 *     Defaults to 'legacy'.
		 *
		 * @!attribute useFipsEndpoint
		 *   @return [Boolean] Enables FIPS compatible endpoints. Defaults to `false`.
		 *
		 * @!attribute useDualstackEndpoint
		 *   @return [Boolean] Enables IPv6 dualstack endpoint. Defaults to `false`.
		 */
		AWS.Config = AWS.util.inherit({
		  /**
		   * @!endgroup
		   */

		  /**
		   * Creates a new configuration object. This is the object that passes
		   * option data along to service requests, including credentials, security,
		   * region information, and some service specific settings.
		   *
		   * @example Creating a new configuration object with credentials and region
		   *   var config = new AWS.Config({
		   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
		   *   });
		   * @option options accessKeyId [String] your AWS access key ID.
		   * @option options secretAccessKey [String] your AWS secret access key.
		   * @option options sessionToken [AWS.Credentials] the optional AWS
		   *   session token to sign requests with.
		   * @option options credentials [AWS.Credentials] the AWS credentials
		   *   to sign requests with. You can either specify this object, or
		   *   specify the accessKeyId and secretAccessKey options directly.
		   * @option options credentialProvider [AWS.CredentialProviderChain] the
		   *   provider chain used to resolve credentials if no static `credentials`
		   *   property is set.
		   * @option options region [String] the region to send service requests to.
		   *   See {region} for more information.
		   * @option options maxRetries [Integer] the maximum amount of retries to
		   *   attempt with a request. See {maxRetries} for more information.
		   * @option options maxRedirects [Integer] the maximum amount of redirects to
		   *   follow with a request. See {maxRedirects} for more information.
		   * @option options sslEnabled [Boolean] whether to enable SSL for
		   *   requests.
		   * @option options paramValidation [Boolean|map] whether input parameters
		   *   should be validated against the operation description before sending
		   *   the request. Defaults to true. Pass a map to enable any of the
		   *   following specific validation features:
		   *
		   *   * **min** [Boolean] &mdash; Validates that a value meets the min
		   *     constraint. This is enabled by default when paramValidation is set
		   *     to `true`.
		   *   * **max** [Boolean] &mdash; Validates that a value meets the max
		   *     constraint.
		   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
		   *     regular expression.
		   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
		   *     of the allowable enum values.
		   * @option options computeChecksums [Boolean] whether to compute checksums
		   *   for payload bodies when the service accepts it (currently supported
		   *   in S3 only)
		   * @option options convertResponseTypes [Boolean] whether types are converted
		   *     when parsing response data. Currently only supported for JSON based
		   *     services. Turning this off may improve performance on large response
		   *     payloads. Defaults to `true`.
		   * @option options correctClockSkew [Boolean] whether to apply a clock skew
		   *     correction and retry requests that fail because of an skewed client
		   *     clock. Defaults to `false`.
		   * @option options s3ForcePathStyle [Boolean] whether to force path
		   *   style URLs for S3 objects.
		   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
		   *   addresses an individual bucket (false if it addresses the root API
		   *   endpoint). Note that setting this configuration option requires an
		   *   `endpoint` to be provided explicitly to the service constructor.
		   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
		   *   should be disabled when using signature version `v4`. Body signing
		   *   can only be disabled when using https. Defaults to `true`.
		   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
		   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
		   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
		   *   Defaults to `legacy`
		   * @option options s3UseArnRegion [Boolean] whether to override the request region
		   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
		   *   Defaults to `true`
		   *
		   * @option options retryDelayOptions [map] A set of options to configure
		   *   the retry delay on retryable errors. Currently supported options are:
		   *
		   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
		   *     exponential backoff for operation retries. Defaults to 100 ms for all
		   *     services except DynamoDB, where it defaults to 50ms.
		   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
		   *     retry count and error and returns the amount of time to delay in
		   *     milliseconds. If the result is a non-zero negative value, no further
		   *     retry attempts will be made. The `base` option will be ignored if this
		   *     option is supplied. The function is only called for retryable errors.
		   * @option options httpOptions [map] A set of options to pass to the low-level
		   *   HTTP request. Currently supported options are:
		   *
		   *   * **proxy** [String] &mdash; the URL to proxy requests through
		   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
		   *     HTTP requests with. Used for connection pooling. Defaults to the global
		   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
		   *     SSL connections, a special Agent object is used in order to enable
		   *     peer certificate verification. This feature is only available in the
		   *     Node.js environment.
		   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
		   *     failing to establish a connection with the server after
		   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
		   *     connection has been established.
		   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
		   *     milliseconds of inactivity on the socket. Defaults to two minutes
		   *     (120000).
		   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
		   *     HTTP requests. Used in the browser environment only. Set to false to
		   *     send requests synchronously. Defaults to true (async on).
		   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
		   *     property of an XMLHttpRequest object. Used in the browser environment
		   *     only. Defaults to false.
		   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
		   *   (or a date) that represents the latest possible API version that can be
		   *   used in all services (unless overridden by `apiVersions`). Specify
		   *   'latest' to use the latest possible version.
		   * @option options apiVersions [map<String, String|Date>] a map of service
		   *   identifiers (the lowercase service class name) with the API version to
		   *   use when instantiating a service. Specify 'latest' for each individual
		   *   that can use the latest available version.
		   * @option options logger [#write,#log] an object that responds to .write()
		   *   (like a stream) or .log() (like the console object) in order to log
		   *   information about requests
		   * @option options systemClockOffset [Number] an offset value in milliseconds
		   *   to apply to all signing times. Use this to compensate for clock skew
		   *   when your system may be out of sync with the service time. Note that
		   *   this configuration option can only be applied to the global `AWS.config`
		   *   object and cannot be overridden in service-specific configuration.
		   *   Defaults to 0 milliseconds.
		   * @option options signatureVersion [String] the signature version to sign
		   *   requests with (overriding the API configuration). Possible values are:
		   *   'v2', 'v3', 'v4'.
		   * @option options signatureCache [Boolean] whether the signature to sign
		   *   requests with (overriding the API configuration) is cached. Only applies
		   *   to the signature version 'v4'. Defaults to `true`.
		   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
		   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
		   * @option options useAccelerateEndpoint [Boolean] Whether to use the
		   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
		   * @option options clientSideMonitoring [Boolean] whether to collect and
		   *   publish this client's performance metrics of all its API requests.
		   * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
		   *   call operations with endpoints given by service dynamically. Setting this
		   * config to `true` will enable endpoint discovery for all applicable operations.
		   *   Setting it to `false` will explicitly disable endpoint discovery even though
		   *   operations that require endpoint discovery will presumably fail. Leaving it
		   *   to `undefined` means SDK will only do endpoint discovery when it's required.
		   *   Defaults to `undefined`
		   * @option options endpointCacheSize [Number] the size of the global cache storing
		   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
		   *   updating this setting cannot change existing cache size.
		   *   Defaults to 1000
		   * @option options hostPrefixEnabled [Boolean] whether to marshal request
		   *   parameters to the prefix of hostname.
		   *   Defaults to `true`.
		   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
		   *   to global endpoints or regional endpoints.
		   *   Defaults to 'legacy'.
		   * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
		   *   Defaults to `false`.
		   * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
		   *   Defaults to `false`.
		   */
		  constructor: function Config(options) {
		    if (options === undefined) options = {};
		    options = this.extractCredentials(options);

		    AWS.util.each.call(this, this.keys, function (key, value) {
		      this.set(key, options[key], value);
		    });
		  },

		  /**
		   * @!group Managing Credentials
		   */

		  /**
		   * Loads credentials from the configuration object. This is used internally
		   * by the SDK to ensure that refreshable {Credentials} objects are properly
		   * refreshed and loaded when sending a request. If you want to ensure that
		   * your credentials are loaded prior to a request, you can use this method
		   * directly to provide accurate credential data stored in the object.
		   *
		   * @note If you configure the SDK with static or environment credentials,
		   *   the credential data should already be present in {credentials} attribute.
		   *   This method is primarily necessary to load credentials from asynchronous
		   *   sources, or sources that can refresh credentials periodically.
		   * @example Getting your access key
		   *   AWS.config.getCredentials(function(err) {
		   *     if (err) console.log(err.stack); // credentials not loaded
		   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
		   *   })
		   * @callback callback function(err)
		   *   Called when the {credentials} have been properly set on the configuration
		   *   object.
		   *
		   *   @param err [Error] if this is set, credentials were not successfully
		   *     loaded and this error provides information why.
		   * @see credentials
		   * @see Credentials
		   */
		  getCredentials: function getCredentials(callback) {
		    var self = this;

		    function finish(err) {
		      callback(err, err ? null : self.credentials);
		    }

		    function credError(msg, err) {
		      return new AWS.util.error(err || new Error(), {
		        code: 'CredentialsError',
		        message: msg,
		        name: 'CredentialsError'
		      });
		    }

		    function getAsyncCredentials() {
		      self.credentials.get(function(err) {
		        if (err) {
		          var msg = 'Could not load credentials from ' +
		            self.credentials.constructor.name;
		          err = credError(msg, err);
		        }
		        finish(err);
		      });
		    }

		    function getStaticCredentials() {
		      var err = null;
		      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
		        err = credError('Missing credentials');
		      }
		      finish(err);
		    }

		    if (self.credentials) {
		      if (typeof self.credentials.get === 'function') {
		        getAsyncCredentials();
		      } else { // static credentials
		        getStaticCredentials();
		      }
		    } else if (self.credentialProvider) {
		      self.credentialProvider.resolve(function(err, creds) {
		        if (err) {
		          err = credError('Could not load credentials from any providers', err);
		        }
		        self.credentials = creds;
		        finish(err);
		      });
		    } else {
		      finish(credError('No credentials to load'));
		    }
		  },

		  /**
		   * Loads token from the configuration object. This is used internally
		   * by the SDK to ensure that refreshable {Token} objects are properly
		   * refreshed and loaded when sending a request. If you want to ensure that
		   * your token is loaded prior to a request, you can use this method
		   * directly to provide accurate token data stored in the object.
		   *
		   * @note If you configure the SDK with static token, the token data should
		   *   already be present in {token} attribute. This method is primarily necessary
		   *   to load token from asynchronous sources, or sources that can refresh
		   *   token periodically.
		   * @example Getting your access token
		   *   AWS.config.getToken(function(err) {
		   *     if (err) console.log(err.stack); // token not loaded
		   *     else console.log("Token:", AWS.config.token.token);
		   *   })
		   * @callback callback function(err)
		   *   Called when the {token} have been properly set on the configuration object.
		   *
		   *   @param err [Error] if this is set, token was not successfully loaded and
		   *     this error provides information why.
		   * @see token
		   */
		  getToken: function getToken(callback) {
		    var self = this;

		    function finish(err) {
		      callback(err, err ? null : self.token);
		    }

		    function tokenError(msg, err) {
		      return new AWS.util.error(err || new Error(), {
		        code: 'TokenError',
		        message: msg,
		        name: 'TokenError'
		      });
		    }

		    function getAsyncToken() {
		      self.token.get(function(err) {
		        if (err) {
		          var msg = 'Could not load token from ' +
		            self.token.constructor.name;
		          err = tokenError(msg, err);
		        }
		        finish(err);
		      });
		    }

		    function getStaticToken() {
		      var err = null;
		      if (!self.token.token) {
		        err = tokenError('Missing token');
		      }
		      finish(err);
		    }

		    if (self.token) {
		      if (typeof self.token.get === 'function') {
		        getAsyncToken();
		      } else { // static token
		        getStaticToken();
		      }
		    } else if (self.tokenProvider) {
		      self.tokenProvider.resolve(function(err, token) {
		        if (err) {
		          err = tokenError('Could not load token from any providers', err);
		        }
		        self.token = token;
		        finish(err);
		      });
		    } else {
		      finish(tokenError('No token to load'));
		    }
		  },

		  /**
		   * @!group Loading and Setting Configuration Options
		   */

		  /**
		   * @overload update(options, allowUnknownKeys = false)
		   *   Updates the current configuration object with new options.
		   *
		   *   @example Update maxRetries property of a configuration object
		   *     config.update({maxRetries: 10});
		   *   @param [Object] options a map of option keys and values.
		   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
		   *     the configuration object. Defaults to `false`.
		   *   @see constructor
		   */
		  update: function update(options, allowUnknownKeys) {
		    allowUnknownKeys = allowUnknownKeys || false;
		    options = this.extractCredentials(options);
		    AWS.util.each.call(this, options, function (key, value) {
		      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
		          AWS.Service.hasService(key)) {
		        this.set(key, value);
		      }
		    });
		  },

		  /**
		   * Loads configuration data from a JSON file into this config object.
		   * @note Loading configuration will reset all existing configuration
		   *   on the object.
		   * @!macro nobrowser
		   * @param path [String] the path relative to your process's current
		   *    working directory to load configuration from.
		   * @return [AWS.Config] the same configuration object
		   */
		  loadFromPath: function loadFromPath(path) {
		    this.clear();

		    var options = JSON.parse(AWS.util.readFileSync(path));
		    var fileSystemCreds = new AWS.FileSystemCredentials(path);
		    var chain = new AWS.CredentialProviderChain();
		    chain.providers.unshift(fileSystemCreds);
		    chain.resolve(function (err, creds) {
		      if (err) throw err;
		      else options.credentials = creds;
		    });

		    this.constructor(options);

		    return this;
		  },

		  /**
		   * Clears configuration data on this object
		   *
		   * @api private
		   */
		  clear: function clear() {
		    /*jshint forin:false */
		    AWS.util.each.call(this, this.keys, function (key) {
		      delete this[key];
		    });

		    // reset credential provider
		    this.set('credentials', undefined);
		    this.set('credentialProvider', undefined);
		  },

		  /**
		   * Sets a property on the configuration object, allowing for a
		   * default value
		   * @api private
		   */
		  set: function set(property, value, defaultValue) {
		    if (value === undefined) {
		      if (defaultValue === undefined) {
		        defaultValue = this.keys[property];
		      }
		      if (typeof defaultValue === 'function') {
		        this[property] = defaultValue.call(this);
		      } else {
		        this[property] = defaultValue;
		      }
		    } else if (property === 'httpOptions' && this[property]) {
		      // deep merge httpOptions
		      this[property] = AWS.util.merge(this[property], value);
		    } else {
		      this[property] = value;
		    }
		  },

		  /**
		   * All of the keys with their default values.
		   *
		   * @constant
		   * @api private
		   */
		  keys: {
		    credentials: null,
		    credentialProvider: null,
		    region: null,
		    logger: null,
		    apiVersions: {},
		    apiVersion: null,
		    endpoint: undefined,
		    httpOptions: {
		      timeout: 120000
		    },
		    maxRetries: undefined,
		    maxRedirects: 10,
		    paramValidation: true,
		    sslEnabled: true,
		    s3ForcePathStyle: false,
		    s3BucketEndpoint: false,
		    s3DisableBodySigning: true,
		    s3UsEast1RegionalEndpoint: 'legacy',
		    s3UseArnRegion: undefined,
		    computeChecksums: true,
		    convertResponseTypes: true,
		    correctClockSkew: false,
		    customUserAgent: null,
		    dynamoDbCrc32: true,
		    systemClockOffset: 0,
		    signatureVersion: null,
		    signatureCache: true,
		    retryDelayOptions: {},
		    useAccelerateEndpoint: false,
		    clientSideMonitoring: false,
		    endpointDiscoveryEnabled: undefined,
		    endpointCacheSize: 1000,
		    hostPrefixEnabled: true,
		    stsRegionalEndpoints: 'legacy',
		    useFipsEndpoint: false,
		    useDualstackEndpoint: false,
		    token: null
		  },

		  /**
		   * Extracts accessKeyId, secretAccessKey and sessionToken
		   * from a configuration hash.
		   *
		   * @api private
		   */
		  extractCredentials: function extractCredentials(options) {
		    if (options.accessKeyId && options.secretAccessKey) {
		      options = AWS.util.copy(options);
		      options.credentials = new AWS.Credentials(options);
		    }
		    return options;
		  },

		  /**
		   * Sets the promise dependency the SDK will use wherever Promises are returned.
		   * Passing `null` will force the SDK to use native Promises if they are available.
		   * If native Promises are not available, passing `null` will have no effect.
		   * @param [Constructor] dep A reference to a Promise constructor
		   */
		  setPromisesDependency: function setPromisesDependency(dep) {
		    PromisesDependency = dep;
		    // if null was passed in, we should try to use native promises
		    if (dep === null && typeof Promise === 'function') {
		      PromisesDependency = Promise;
		    }
		    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
		    if (AWS.S3) {
		      constructors.push(AWS.S3);
		      if (AWS.S3.ManagedUpload) {
		        constructors.push(AWS.S3.ManagedUpload);
		      }
		    }
		    AWS.util.addPromises(constructors, PromisesDependency);
		  },

		  /**
		   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
		   */
		  getPromisesDependency: function getPromisesDependency() {
		    return PromisesDependency;
		  }
		});

		/**
		 * @return [AWS.Config] The global configuration object singleton instance
		 * @readonly
		 * @see AWS.Config
		 */
		AWS.config = new AWS.Config();


	/***/ }),
	/* 47 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);

		/**
		 * Represents your AWS security credentials, specifically the
		 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
		 * Creating a `Credentials` object allows you to pass around your
		 * security information to configuration and service objects.
		 *
		 * Note that this class typically does not need to be constructed manually,
		 * as the {AWS.Config} and {AWS.Service} classes both accept simple
		 * options hashes with the three keys. These structures will be converted
		 * into Credentials objects automatically.
		 *
		 * ## Expiring and Refreshing Credentials
		 *
		 * Occasionally credentials can expire in the middle of a long-running
		 * application. In this case, the SDK will automatically attempt to
		 * refresh the credentials from the storage location if the Credentials
		 * class implements the {refresh} method.
		 *
		 * If you are implementing a credential storage location, you
		 * will want to create a subclass of the `Credentials` class and
		 * override the {refresh} method. This method allows credentials to be
		 * retrieved from the backing store, be it a file system, database, or
		 * some network storage. The method should reset the credential attributes
		 * on the object.
		 *
		 * @!attribute expired
		 *   @return [Boolean] whether the credentials have been expired and
		 *     require a refresh. Used in conjunction with {expireTime}.
		 * @!attribute expireTime
		 *   @return [Date] a time when credentials should be considered expired. Used
		 *     in conjunction with {expired}.
		 * @!attribute accessKeyId
		 *   @return [String] the AWS access key ID
		 * @!attribute secretAccessKey
		 *   @return [String] the AWS secret access key
		 * @!attribute sessionToken
		 *   @return [String] an optional AWS session token
		 */
		AWS.Credentials = AWS.util.inherit({
		  /**
		   * A credentials object can be created using positional arguments or an options
		   * hash.
		   *
		   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
		   *   Creates a Credentials object with a given set of credential information
		   *   as positional arguments.
		   *   @param accessKeyId [String] the AWS access key ID
		   *   @param secretAccessKey [String] the AWS secret access key
		   *   @param sessionToken [String] the optional AWS session token
		   *   @example Create a credentials object with AWS credentials
		   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
		   * @overload AWS.Credentials(options)
		   *   Creates a Credentials object with a given set of credential information
		   *   as an options hash.
		   *   @option options accessKeyId [String] the AWS access key ID
		   *   @option options secretAccessKey [String] the AWS secret access key
		   *   @option options sessionToken [String] the optional AWS session token
		   *   @example Create a credentials object with AWS credentials
		   *     var creds = new AWS.Credentials({
		   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
		   *     });
		   */
		  constructor: function Credentials() {
		    // hide secretAccessKey from being displayed with util.inspect
		    AWS.util.hideProperties(this, ['secretAccessKey']);

		    this.expired = false;
		    this.expireTime = null;
		    this.refreshCallbacks = [];
		    if (arguments.length === 1 && typeof arguments[0] === 'object') {
		      var creds = arguments[0].credentials || arguments[0];
		      this.accessKeyId = creds.accessKeyId;
		      this.secretAccessKey = creds.secretAccessKey;
		      this.sessionToken = creds.sessionToken;
		    } else {
		      this.accessKeyId = arguments[0];
		      this.secretAccessKey = arguments[1];
		      this.sessionToken = arguments[2];
		    }
		  },

		  /**
		   * @return [Integer] the number of seconds before {expireTime} during which
		   *   the credentials will be considered expired.
		   */
		  expiryWindow: 15,

		  /**
		   * @return [Boolean] whether the credentials object should call {refresh}
		   * @note Subclasses should override this method to provide custom refresh
		   *   logic.
		   */
		  needsRefresh: function needsRefresh() {
		    var currentTime = AWS.util.date.getDate().getTime();
		    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

		    if (this.expireTime && adjustedTime > this.expireTime) {
		      return true;
		    } else {
		      return this.expired || !this.accessKeyId || !this.secretAccessKey;
		    }
		  },

		  /**
		   * Gets the existing credentials, refreshing them if they are not yet loaded
		   * or have expired. Users should call this method before using {refresh},
		   * as this will not attempt to reload credentials when they are already
		   * loaded into the object.
		   *
		   * @callback callback function(err)
		   *   When this callback is called with no error, it means either credentials
		   *   do not need to be refreshed or refreshed credentials information has
		   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
		   *   and `sessionToken` properties).
		   *   @param err [Error] if an error occurred, this value will be filled
		   */
		  get: function get(callback) {
		    var self = this;
		    if (this.needsRefresh()) {
		      this.refresh(function(err) {
		        if (!err) self.expired = false; // reset expired flag
		        if (callback) callback(err);
		      });
		    } else if (callback) {
		      callback();
		    }
		  },

		  /**
		   * @!method  getPromise()
		   *   Returns a 'thenable' promise.
		   *   Gets the existing credentials, refreshing them if they are not yet loaded
		   *   or have expired. Users should call this method before using {refresh},
		   *   as this will not attempt to reload credentials when they are already
		   *   loaded into the object.
		   *
		   *   Two callbacks can be provided to the `then` method on the returned promise.
		   *   The first callback will be called if the promise is fulfilled, and the second
		   *   callback will be called if the promise is rejected.
		   *   @callback fulfilledCallback function()
		   *     Called if the promise is fulfilled. When this callback is called, it
		   *     means either credentials do not need to be refreshed or refreshed
		   *     credentials information has been loaded into the object (as the
		   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
		   *   @callback rejectedCallback function(err)
		   *     Called if the promise is rejected.
		   *     @param err [Error] if an error occurred, this value will be filled
		   *   @return [Promise] A promise that represents the state of the `get` call.
		   *   @example Calling the `getPromise` method.
		   *     var promise = credProvider.getPromise();
		   *     promise.then(function() { ... }, function(err) { ... });
		   */

		  /**
		   * @!method  refreshPromise()
		   *   Returns a 'thenable' promise.
		   *   Refreshes the credentials. Users should call {get} before attempting
		   *   to forcibly refresh credentials.
		   *
		   *   Two callbacks can be provided to the `then` method on the returned promise.
		   *   The first callback will be called if the promise is fulfilled, and the second
		   *   callback will be called if the promise is rejected.
		   *   @callback fulfilledCallback function()
		   *     Called if the promise is fulfilled. When this callback is called, it
		   *     means refreshed credentials information has been loaded into the object
		   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
		   *   @callback rejectedCallback function(err)
		   *     Called if the promise is rejected.
		   *     @param err [Error] if an error occurred, this value will be filled
		   *   @return [Promise] A promise that represents the state of the `refresh` call.
		   *   @example Calling the `refreshPromise` method.
		   *     var promise = credProvider.refreshPromise();
		   *     promise.then(function() { ... }, function(err) { ... });
		   */

		  /**
		   * Refreshes the credentials. Users should call {get} before attempting
		   * to forcibly refresh credentials.
		   *
		   * @callback callback function(err)
		   *   When this callback is called with no error, it means refreshed
		   *   credentials information has been loaded into the object (as the
		   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
		   *   @param err [Error] if an error occurred, this value will be filled
		   * @note Subclasses should override this class to reset the
		   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
		   *   on the credentials object and then call the callback with
		   *   any error information.
		   * @see get
		   */
		  refresh: function refresh(callback) {
		    this.expired = false;
		    callback();
		  },

		  /**
		   * @api private
		   * @param callback
		   */
		  coalesceRefresh: function coalesceRefresh(callback, sync) {
		    var self = this;
		    if (self.refreshCallbacks.push(callback) === 1) {
		      self.load(function onLoad(err) {
		        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
		          if (sync) {
		            callback(err);
		          } else {
		            // callback could throw, so defer to ensure all callbacks are notified
		            AWS.util.defer(function () {
		              callback(err);
		            });
		          }
		        });
		        self.refreshCallbacks.length = 0;
		      });
		    }
		  },

		  /**
		   * @api private
		   * @param callback
		   */
		  load: function load(callback) {
		    callback();
		  }
		});

		/**
		 * @api private
		 */
		AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
		  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
		  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
		};

		/**
		 * @api private
		 */
		AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
		  delete this.prototype.getPromise;
		  delete this.prototype.refreshPromise;
		};

		AWS.util.addPromises(AWS.Credentials);


	/***/ }),
	/* 48 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);

		/**
		 * Creates a credential provider chain that searches for AWS credentials
		 * in a list of credential providers specified by the {providers} property.
		 *
		 * By default, the chain will use the {defaultProviders} to resolve credentials.
		 * These providers will look in the environment using the
		 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
		 *
		 * ## Setting Providers
		 *
		 * Each provider in the {providers} list should be a function that returns
		 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
		 * form allows for delayed execution of the credential construction.
		 *
		 * ## Resolving Credentials from a Chain
		 *
		 * Call {resolve} to return the first valid credential object that can be
		 * loaded by the provider chain.
		 *
		 * For example, to resolve a chain with a custom provider that checks a file
		 * on disk after the set of {defaultProviders}:
		 *
		 * ```javascript
		 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
		 * var chain = new AWS.CredentialProviderChain();
		 * chain.providers.push(diskProvider);
		 * chain.resolve();
		 * ```
		 *
		 * The above code will return the `diskProvider` object if the
		 * file contains credentials and the `defaultProviders` do not contain
		 * any credential settings.
		 *
		 * @!attribute providers
		 *   @return [Array<AWS.Credentials, Function>]
		 *     a list of credentials objects or functions that return credentials
		 *     objects. If the provider is a function, the function will be
		 *     executed lazily when the provider needs to be checked for valid
		 *     credentials. By default, this object will be set to the
		 *     {defaultProviders}.
		 *   @see defaultProviders
		 */
		AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

		  /**
		   * Creates a new CredentialProviderChain with a default set of providers
		   * specified by {defaultProviders}.
		   */
		  constructor: function CredentialProviderChain(providers) {
		    if (providers) {
		      this.providers = providers;
		    } else {
		      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
		    }
		    this.resolveCallbacks = [];
		  },

		  /**
		   * @!method  resolvePromise()
		   *   Returns a 'thenable' promise.
		   *   Resolves the provider chain by searching for the first set of
		   *   credentials in {providers}.
		   *
		   *   Two callbacks can be provided to the `then` method on the returned promise.
		   *   The first callback will be called if the promise is fulfilled, and the second
		   *   callback will be called if the promise is rejected.
		   *   @callback fulfilledCallback function(credentials)
		   *     Called if the promise is fulfilled and the provider resolves the chain
		   *     to a credentials object
		   *     @param credentials [AWS.Credentials] the credentials object resolved
		   *       by the provider chain.
		   *   @callback rejectedCallback function(error)
		   *     Called if the promise is rejected.
		   *     @param err [Error] the error object returned if no credentials are found.
		   *   @return [Promise] A promise that represents the state of the `resolve` method call.
		   *   @example Calling the `resolvePromise` method.
		   *     var promise = chain.resolvePromise();
		   *     promise.then(function(credentials) { ... }, function(err) { ... });
		   */

		  /**
		   * Resolves the provider chain by searching for the first set of
		   * credentials in {providers}.
		   *
		   * @callback callback function(err, credentials)
		   *   Called when the provider resolves the chain to a credentials object
		   *   or null if no credentials can be found.
		   *
		   *   @param err [Error] the error object returned if no credentials are
		   *     found.
		   *   @param credentials [AWS.Credentials] the credentials object resolved
		   *     by the provider chain.
		   * @return [AWS.CredentialProviderChain] the provider, for chaining.
		   */
		  resolve: function resolve(callback) {
		    var self = this;
		    if (self.providers.length === 0) {
		      callback(new Error('No providers'));
		      return self;
		    }

		    if (self.resolveCallbacks.push(callback) === 1) {
		      var index = 0;
		      var providers = self.providers.slice(0);

		      function resolveNext(err, creds) {
		        if ((!err && creds) || index === providers.length) {
		          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
		            callback(err, creds);
		          });
		          self.resolveCallbacks.length = 0;
		          return;
		        }

		        var provider = providers[index++];
		        if (typeof provider === 'function') {
		          creds = provider.call();
		        } else {
		          creds = provider;
		        }

		        if (creds.get) {
		          creds.get(function (getErr) {
		            resolveNext(getErr, getErr ? null : creds);
		          });
		        } else {
		          resolveNext(null, creds);
		        }
		      }

		      resolveNext();
		    }

		    return self;
		  }
		});

		/**
		 * The default set of providers used by a vanilla CredentialProviderChain.
		 *
		 * In the browser:
		 *
		 * ```javascript
		 * AWS.CredentialProviderChain.defaultProviders = []
		 * ```
		 *
		 * In Node.js:
		 *
		 * ```javascript
		 * AWS.CredentialProviderChain.defaultProviders = [
		 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
		 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
		 *   function () { return new AWS.SsoCredentials(); },
		 *   function () { return new AWS.SharedIniFileCredentials(); },
		 *   function () { return new AWS.ECSCredentials(); },
		 *   function () { return new AWS.ProcessCredentials(); },
		 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
		 *   function () { return new AWS.EC2MetadataCredentials() }
		 * ]
		 * ```
		 */
		AWS.CredentialProviderChain.defaultProviders = [];

		/**
		 * @api private
		 */
		AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
		  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
		};

		/**
		 * @api private
		 */
		AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
		  delete this.prototype.resolvePromise;
		};

		AWS.util.addPromises(AWS.CredentialProviderChain);


	/***/ }),
	/* 49 */
	/***/ (function(module, exports, __webpack_require__) {

		var AWS = __webpack_require__(1);
		var inherit = AWS.util.inherit;

		/**
		 * The endpoint that a service will talk to, for example,
		 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
		 * you need to override an endpoint for a service, you can
		 * set the endpoint on a service by passing the endpoint
		 * object with the `endpoint` option key:
		 *
		 * ```javascript
		 * var ep = new AWS.Endpoint('awsproxy.example.com');
		 * var s3 = new AWS.S3({endpoint: ep});
		 * s3.service.endpoint.hostname == 'awsproxy.example.com'
		 * ```
		 *
		 * Note that if you do not specify a protocol, the protocol will
		 * be selected based on your current {AWS.config} configuration.
		 *
		 * @!attribute protocol
		 *   @return [String] the protocol (http or https) of the endpoint
		 *     URL
		 * @!attribute hostname
		 *   @return [String] the host portion of the endpoint, e.g.,
		 *     example.com
		 * @!attribute host
		 *   @return [String] the host portion of the endpoint including
		 *     the port, e.g., example.com:80
		 * @!attribute port
		 *   @return [Integer] the port of the endpoint
		 * @!attribute href
		 *   @return [String] the full URL of the endpoint
		 */
		AWS.Endpoint = inherit({

		  /**
		   * @overload Endpoint(endpoint)
		   *   Constructs a new endpoint given an endpoint URL. If the
		   *   URL omits a protocol (http or https), the default protocol
		   *   set in the global {AWS.config} will be used.
		   *   @param endpoint [String] the URL to construct an endpoint from
		   */
		  constructor: function Endpoint(endpoint, config) {
		    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

		    if (typeof endpoint === 'undefined' || endpoint === null) {
		      throw new Error('Invalid endpoint: ' + endpoint);
		    } else if (typeof endpoint !== 'string') {
		      return AWS.util.copy(endpoint);
		    }

		    if (!endpoint.match(/^http/)) {
		      var useSSL = config && config.sslEnabled !== undefined ?
		        config.sslEnabled : AWS.config.sslEnabled;
		      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
		    }

		    AWS.util.update(this, AWS.util.urlParse(endpoint));

		    // Ensure the port property is set as an integer
		    if (this.port) {
		      this.port = parseInt(this.port, 10);
		    } else {
		      this.port = this.protocol === 'https:' ? 443 : 80;
		    }
		  }

		});

		/**
		 * The low level HTTP request object, encapsulating all HTTP header
		 * and body data sent by a service request.
		 *
		 * @!attribute method
		 *   @return [String] the HTTP method of the request
		 * @!attribute path
		 *   @return [String] the path portion of the URI, e.g.,
		 *     "/list/?start=5&num=10"
		 * @!attribute headers
		 *   @return [map<String,String>]
		 *     a map of header keys and their respective values
		 * @!attribute body
		 *   @return [String] the request body payload
		 * @!attribute endpoint
		 *   @return [AWS.Endpoint] the endpoint for the request
		 * @!attribute region
		 *   @api private
		 *   @return [String] the region, for signing purposes only.
		 */
		AWS.HttpRequest = inherit({

		  /**
		   * @api private
		   */
		  constructor: function HttpRequest(endpoint, region) {
		    endpoint = new AWS.Endpoint(endpoint);
		    this.method = 'POST';
		    this.path = endpoint.path || '/';
		    this.headers = {};
		    this.body = '';
		    this.endpoint = endpoint;
		    this.region = region;
		    this._userAgent = '';
		    this.setUserAgent();
		  },

		  /**
		   * @api private
		   */
		  setUserAgent: function setUserAgent() {
		    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
		  },

		  getUserAgentHeaderName: function getUserAgentHeaderName() {
		    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
		    return prefix + 'User-Agent';
		  },

		  /**
		   * @api private
		   */
		  appendToUserAgent: function appendToUserAgent(agentPartial) {
		    if (typeof agentPartial === 'string' && agentPartial) {
		      this._userAgent += ' ' + agentPartial;
		    }
		    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
		  },

		  /**
		   * @api private
		   */
		  getUserAgent: function getUserAgent() {
		    return this._userAgent;
		  },

		  /**
		   * @return [String] the part of the {path} excluding the
		   *   query string
		   */
		  pathname: function pathname() {
		    return this.path.split('?', 1)[0];
		  },

		  /**
		   * @return [String] the query string portion of the {path}
		   */
		  search: function search() {
		    var query = this.path.split('?', 2)[1];
		    if (query) {
		      query = AWS.util.queryStringParse(query);
		      return AWS.util.queryParamsToString(query);
		    }
		    return '';
		  },

		  /**
		   * @api private
		   * update httpRequest endpoint with endpoint string
		   */
		  updateEndpoint: function updateEndpoint(endpointStr) {
		    var newEndpoint = new AWS.Endpoint(endpointStr);
		    this.endpoint = newEndpoint;
		    this.path = newEndpoint.path || '/';
		    if (this.headers['Host']) {
		      this.headers['Host'] = newEndpoint.host;
		    }
		  }
		});

		/**
		 * The low level HTTP response object, encapsulating all HTTP header
		 * and body data returned from the request.
		 *
		 * @!attribute statusCode
		 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
		 * @!attribute headers
		 *   @return [map<String,String>]
		 *      a map of response header keys and their respective values
		 * @!attribute body
		 *   @return [String] the response body payload
		 * @!attribute [r] streaming
		 *   @return [Boolean] whether this response is being streamed at a low-level.
		 *     Defaults to `false` (buffered reads). Do not modify this manually, use
		 *     {createUnbufferedStream} to convert the stream to unbuffered mode
		 *     instead.
		 */
		AWS.HttpResponse = inherit({

		  /**
		   * @api private
		   */
		  constructor: function HttpResponse() {
		    this.statusCode = undefined;
		    this.headers = {};
		    this.body = undefined;
		    this.streaming = false;
		    this.stream = null;
		  },

		  /**
		   * Disables buffering on the HTTP response and returns the stream for reading.
		   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
		   *   Use this object to directly read data off of the stream.
		   * @note This object is only available after the {AWS.Request~httpHeaders}
		   *   event has fired. This method must be called prior to
		   *   {AWS.Request~httpData}.
		   * @example Taking control of a stream
		   *   request.on('httpHeaders', function(statusCode, headers) {
		   *     if (statusCode < 300) {
		   *       if (headers.etag === 'xyz') {
		   *         // pipe the stream, disabling buffering
		   *         var stream = this.response.httpResponse.createUnbufferedStream();
		   *         stream.pipe(process.stdout);
		   *       } else { // abort this request and set a better error message
		   *         this.abort();
		   *         this.response.error = new Error('Invalid ETag');
		   *       }
		   *     }
		   *   }).send(console.log);
		   */
		  createUnbufferedStream: function createUnbufferedStream() {
		    this.streaming = true;
		    return this.stream;
		  }
		});


		AWS.HttpClient = inherit({});

		/**
		 * @api private
		 */
		AWS.HttpClient.getInstance = function getInstance() {
		  if (this.singleton === undefined) {
		    this.singleton = new this();
		  }
		  return this.singleton;
		};


	/***/ }),
	/* 50 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {var AWS = __webpack_require__(1);
		var SequentialExecutor = __webpack_require__(41);
		var DISCOVER_ENDPOINT = __webpack_require__(51).discoverEndpoint;
		/**
		 * The namespace used to register global event listeners for request building
		 * and sending.
		 */
		AWS.EventListeners = {
		  /**
		   * @!attribute VALIDATE_CREDENTIALS
		   *   A request listener that validates whether the request is being
		   *   sent with credentials.
		   *   Handles the {AWS.Request~validate 'validate' Request event}
		   *   @example Sending a request without validating credentials
		   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
		   *     request.removeListener('validate', listener);
		   *   @readonly
		   *   @return [Function]
		   * @!attribute VALIDATE_REGION
		   *   A request listener that validates whether the region is set
		   *   for a request.
		   *   Handles the {AWS.Request~validate 'validate' Request event}
		   *   @example Sending a request without validating region configuration
		   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
		   *     request.removeListener('validate', listener);
		   *   @readonly
		   *   @return [Function]
		   * @!attribute VALIDATE_PARAMETERS
		   *   A request listener that validates input parameters in a request.
		   *   Handles the {AWS.Request~validate 'validate' Request event}
		   *   @example Sending a request without validating parameters
		   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
		   *     request.removeListener('validate', listener);
		   *   @example Disable parameter validation globally
		   *     AWS.EventListeners.Core.removeListener('validate',
		   *       AWS.EventListeners.Core.VALIDATE_REGION);
		   *   @readonly
		   *   @return [Function]
		   * @!attribute SEND
		   *   A request listener that initiates the HTTP connection for a
		   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
		   *   @example Replacing the HTTP handler
		   *     var listener = AWS.EventListeners.Core.SEND;
		   *     request.removeListener('send', listener);
		   *     request.on('send', function(response) {
		   *       customHandler.send(response);
		   *     });
		   *   @return [Function]
		   *   @readonly
		   * @!attribute HTTP_DATA
		   *   A request listener that reads data from the HTTP connection in order
		   *   to build the response data.
		   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
		   *   Remove this handler if you are overriding the 'httpData' event and
		   *   do not want extra data processing and buffering overhead.
		   *   @example Disabling default data processing
		   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
		   *     request.removeListener('httpData', listener);
		   *   @return [Function]
		   *   @readonly
		   */
		  Core: {} /* doc hack */
		};

		/**
		 * @api private
		 */
		function getOperationAuthtype(req) {
		  if (!req.service.api.operations) {
		    return '';
		  }
		  var operation = req.service.api.operations[req.operation];
		  return operation ? operation.authtype : '';
		}

		AWS.EventListeners = {
		  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
		    addAsync('VALIDATE_CREDENTIALS', 'validate',
		        function VALIDATE_CREDENTIALS(req, done) {
		      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
		      req.service.config.getCredentials(function(err) {
		        if (err) {
		          req.response.error = AWS.util.error(err,
		            {code: 'CredentialsError', message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1'});
		        }
		        done();
		      });
		    });

		    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
		      if (!req.service.isGlobalEndpoint) {
		        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
		        if (!req.service.config.region) {
		          req.response.error = AWS.util.error(new Error(),
		            {code: 'ConfigError', message: 'Missing region in config'});
		        } else if (!dnsHostRegex.test(req.service.config.region)) {
		          req.response.error = AWS.util.error(new Error(),
		            {code: 'ConfigError', message: 'Invalid region in config'});
		        }
		      }
		    });

		    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
		      if (!req.service.api.operations) {
		        return;
		      }
		      var operation = req.service.api.operations[req.operation];
		      if (!operation) {
		        return;
		      }
		      var idempotentMembers = operation.idempotentMembers;
		      if (!idempotentMembers.length) {
		        return;
		      }
		      // creates a copy of params so user's param object isn't mutated
		      var params = AWS.util.copy(req.params);
		      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
		        if (!params[idempotentMembers[i]]) {
		          // add the member
		          params[idempotentMembers[i]] = AWS.util.uuid.v4();
		        }
		      }
		      req.params = params;
		    });

		    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
		      if (!req.service.api.operations) {
		        return;
		      }
		      var rules = req.service.api.operations[req.operation].input;
		      var validation = req.service.config.paramValidation;
		      new AWS.ParamValidator(validation).validate(rules, req.params);
		    });

		    add('COMPUTE_CHECKSUM', 'afterBuild', function COMPUTE_CHECKSUM(req) {
		      if (!req.service.api.operations) {
		        return;
		      }
		      var operation = req.service.api.operations[req.operation];
		      if (!operation) {
		        return;
		      }
		      var body = req.httpRequest.body;
		      var isNonStreamingPayload = body && (AWS.util.Buffer.isBuffer(body) || typeof body === 'string');
		      var headers = req.httpRequest.headers;
		      if (
		        operation.httpChecksumRequired &&
		        req.service.config.computeChecksums &&
		        isNonStreamingPayload &&
		        !headers['Content-MD5']
		      ) {
		        var md5 = AWS.util.crypto.md5(body, 'base64');
		        headers['Content-MD5'] = md5;
		      }
		    });

		    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
		      req.haltHandlersOnError();
		      if (!req.service.api.operations) {
		        return;
		      }
		      var operation = req.service.api.operations[req.operation];
		      var authtype = operation ? operation.authtype : '';
		      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
		      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
		        var body = req.httpRequest.body || '';
		        if (authtype.indexOf('unsigned-body') >= 0) {
		          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
		          return done();
		        }
		        AWS.util.computeSha256(body, function(err, sha) {
		          if (err) {
		            done(err);
		          }
		          else {
		            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
		            done();
		          }
		        });
		      } else {
		        done();
		      }
		    });

		    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
		      var authtype = getOperationAuthtype(req);
		      var payloadMember = AWS.util.getRequestPayloadShape(req);
		      if (req.httpRequest.headers['Content-Length'] === undefined) {
		        try {
		          var length = AWS.util.string.byteLength(req.httpRequest.body);
		          req.httpRequest.headers['Content-Length'] = length;
		        } catch (err) {
		          if (payloadMember && payloadMember.isStreaming) {
		            if (payloadMember.requiresLength) {
		              //streaming payload requires length(s3, glacier)
		              throw err;
		            } else if (authtype.indexOf('unsigned-body') >= 0) {
		              //unbounded streaming payload(lex, mediastore)
		              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
		              return;
		            } else {
		              throw err;
		            }
		          }
		          throw err;
		        }
		      }
		    });

		    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
		      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
		    });

		    add('SET_TRACE_ID', 'afterBuild', function SET_TRACE_ID(req) {
		      var traceIdHeaderName = 'X-Amzn-Trace-Id';
		      if (AWS.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
		        var ENV_LAMBDA_FUNCTION_NAME = 'AWS_LAMBDA_FUNCTION_NAME';
		        var ENV_TRACE_ID = '_X_AMZN_TRACE_ID';
		        var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
		        var traceId = process.env[ENV_TRACE_ID];
		        if (
		          typeof functionName === 'string' &&
		          functionName.length > 0 &&
		          typeof traceId === 'string' &&
		          traceId.length > 0
		        ) {
		          req.httpRequest.headers[traceIdHeaderName] = traceId;
		        }
		      }
		    });

		    add('RESTART', 'restart', function RESTART() {
		      var err = this.response.error;
		      if (!err || !err.retryable) return;

		      this.httpRequest = new AWS.HttpRequest(
		        this.service.endpoint,
		        this.service.region
		      );

		      if (this.response.retryCount < this.service.config.maxRetries) {
		        this.response.retryCount++;
		      } else {
		        this.response.error = null;
		      }
		    });

		    var addToHead = true;
		    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

		    addAsync('SIGN', 'sign', function SIGN(req, done) {
		      var service = req.service;
		      var operations = req.service.api.operations || {};
		      var operation = operations[req.operation];
		      var authtype = operation ? operation.authtype : '';
		      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

		      if (authtype === 'bearer' || service.config.signatureVersion === 'bearer') {
		        service.config.getToken(function (err, token) {
		          if (err) {
		            req.response.error = err;
		            return done();
		          }

		          try {
		            var SignerClass = service.getSignerClass(req);
		            var signer = new SignerClass(req.httpRequest);
		            signer.addAuthorization(token);
		          } catch (e) {
		            req.response.error = e;
		          }
		          done();
		        });
		      } else {
		        service.config.getCredentials(function (err, credentials) {
		          if (err) {
		            req.response.error = err;
		            return done();
		          }

		          try {
		            var date = service.getSkewCorrectedDate();
		            var SignerClass = service.getSignerClass(req);
		            var signer = new SignerClass(req.httpRequest,
		              service.getSigningName(req),
		              {
		                signatureCache: service.config.signatureCache,
		                operation: operation,
		                signatureVersion: service.api.signatureVersion
		              });
		            signer.setServiceClientId(service._clientId);

		            // clear old authorization headers
		            delete req.httpRequest.headers['Authorization'];
		            delete req.httpRequest.headers['Date'];
		            delete req.httpRequest.headers['X-Amz-Date'];

		            // add new authorization
		            signer.addAuthorization(credentials, date);
		            req.signedAt = date;
		          } catch (e) {
		            req.response.error = e;
		          }
		          done();
		        });

		      }
		    });

		    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
		      if (this.service.successfulResponse(resp, this)) {
		        resp.data = {};
		        resp.error = null;
		      } else {
		        resp.data = null;
		        resp.error = AWS.util.error(new Error(),
		          {code: 'UnknownError', message: 'An unknown error occurred.'});
		      }
		    });

		    add('ERROR', 'error', function ERROR(err, resp) {
		      var awsQueryCompatible = resp.request.service.api.awsQueryCompatible;
		      if (awsQueryCompatible) {
		        var headers = resp.httpResponse.headers;
		        var queryErrorCode = headers ? headers['x-amzn-query-error'] : undefined;
		        if (queryErrorCode && queryErrorCode.includes(';')) {
		          resp.error.code = queryErrorCode.split(';')[0];
		        }
		      }
		    }, true);

		    addAsync('SEND', 'send', function SEND(resp, done) {
		      resp.httpResponse._abortCallback = done;
		      resp.error = null;
		      resp.data = null;

		      function callback(httpResp) {
		        resp.httpResponse.stream = httpResp;
		        var stream = resp.request.httpRequest.stream;
		        var service = resp.request.service;
		        var api = service.api;
		        var operationName = resp.request.operation;
		        var operation = api.operations[operationName] || {};

		        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
		          resp.request.emit(
		            'httpHeaders',
		            [statusCode, headers, resp, statusMessage]
		          );

		          if (!resp.httpResponse.streaming) {
		            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
		              // if we detect event streams, we're going to have to
		              // return the stream immediately
		              if (operation.hasEventOutput && service.successfulResponse(resp)) {
		                // skip reading the IncomingStream
		                resp.request.emit('httpDone');
		                done();
		                return;
		              }

		              httpResp.on('readable', function onReadable() {
		                var data = httpResp.read();
		                if (data !== null) {
		                  resp.request.emit('httpData', [data, resp]);
		                }
		              });
		            } else { // legacy streams API
		              httpResp.on('data', function onData(data) {
		                resp.request.emit('httpData', [data, resp]);
		              });
		            }
		          }
		        });

		        httpResp.on('end', function onEnd() {
		          if (!stream || !stream.didCallback) {
		            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
		              // don't concatenate response chunks when streaming event stream data when response is successful
		              return;
		            }
		            resp.request.emit('httpDone');
		            done();
		          }
		        });
		      }

		      function progress(httpResp) {
		        httpResp.on('sendProgress', function onSendProgress(value) {
		          resp.request.emit('httpUploadProgress', [value, resp]);
		        });

		        httpResp.on('receiveProgress', function onReceiveProgress(value) {
		          resp.request.emit('httpDownloadProgress', [value, resp]);
		        });
		      }

		      function error(err) {
		        if (err.code !== 'RequestAbortedError') {
		          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
		          err = AWS.util.error(err, {
		            code: errCode,
		            region: resp.request.httpRequest.region,
		            hostname: resp.request.httpRequest.endpoint.hostname,
		            retryable: true
		          });
		        }
		        resp.error = err;
		        resp.request.emit('httpError', [resp.error, resp], function() {
		          done();
		        });
		      }

		      function executeSend() {
		        var http = AWS.HttpClient.getInstance();
		        var httpOptions = resp.request.service.config.httpOptions || {};
		        try {
		          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
		                                          callback, error);
		          progress(stream);
		        } catch (err) {
		          error(err);
		        }
		      }
		      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
		      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
		        this.emit('sign', [this], function(err) {
		          if (err) done(err);
		          else executeSend();
		        });
		      } else {
		        executeSend();
		      }
		    });

		    add('HTTP_HEADERS', 'httpHeaders',
		        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
		      resp.httpResponse.statusCode = statusCode;
		      resp.httpResponse.statusMessage = statusMessage;
		      resp.httpResponse.headers = headers;
		      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
		      resp.httpResponse.buffers = [];
		      resp.httpResponse.numBytes = 0;
		      var dateHeader = headers.date || headers.Date;
		      var service = resp.request.service;
		      if (dateHeader) {
		        var serverTime = Date.parse(dateHeader);
		        if (service.config.correctClockSkew
		            && service.isClockSkewed(serverTime)) {
		          service.applyClockOffset(serverTime);
		        }
		      }
		    });

		    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
		      if (chunk) {
		        if (AWS.util.isNode()) {
		          resp.httpResponse.numBytes += chunk.length;

		          var total = resp.httpResponse.headers['content-length'];
		          var progress = { loaded: resp.httpResponse.numBytes, total: total };
		          resp.request.emit('httpDownloadProgress', [progress, resp]);
		        }

		        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
		      }
		    });

		    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
		      // convert buffers array into single buffer
		      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
		        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
		        resp.httpResponse.body = body;
		      }
		      delete resp.httpResponse.numBytes;
		      delete resp.httpResponse.buffers;
		    });

		    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
		      if (resp.httpResponse.statusCode) {
		        resp.error.statusCode = resp.httpResponse.statusCode;
		        if (resp.error.retryable === undefined) {
		          resp.error.retryable = this.service.retryableError(resp.error, this);
		        }
		      }
		    });

		    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
		      if (!resp.error) return;
		      switch (resp.error.code) {
		        case 'RequestExpired': // EC2 only
		        case 'ExpiredTokenException':
		        case 'ExpiredToken':
		          resp.error.retryable = true;
		          resp.request.service.config.credentials.expired = true;
		      }
		    });

		    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
		      var err = resp.error;
		      if (!err) return;
		      if (typeof err.code === 'string' && typeof err.message === 'string') {
		        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
		          resp.error.retryable = true;
		        }
		      }
		    });

		    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
		      if (!resp.error) return;
		      if (this.service.clockSkewError(resp.error)
		          && this.service.config.correctClockSkew) {
		        resp.error.retryable = true;
		      }
		    });

		    add('REDIRECT', 'retry', function REDIRECT(resp) {
		      if (resp.error && resp.error.statusCode >= 300 &&
		          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
		        this.httpRequest.endpoint =
		          new AWS.Endpoint(resp.httpResponse.headers['location']);
		        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
		        resp.error.redirect = true;
		        resp.error.retryable = true;
		      }
		    });

		    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
		      if (resp.error) {
		        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
		          resp.error.retryDelay = 0;
		        } else if (resp.retryCount < resp.maxRetries) {
		          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
		        }
		      }
		    });

		    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
		      var delay, willRetry = false;

		      if (resp.error) {
		        delay = resp.error.retryDelay || 0;
		        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
		          resp.retryCount++;
		          willRetry = true;
		        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
		          resp.redirectCount++;
		          willRetry = true;
		        }
		      }

		      // delay < 0 is a signal from customBackoff to skip retries
		      if (willRetry && delay >= 0) {
		        resp.error = null;
		        setTimeout(done, delay);
		      } else {
		        done();
		      }
		    });
		  }),

		  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
		    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
		    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

		    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
		      function isDNSError(err) {
		        return err.errno === 'ENOTFOUND' ||
		          typeof err.errno === 'number' &&
		          typeof AWS.util.getSystemErrorName === 'function' &&
		          ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS.util.getSystemErrorName(err.errno) >= 0);
		      }
		      if (err.code === 'NetworkingError' && isDNSError(err)) {
		        var message = 'Inaccessible host: `' + err.hostname + '\' at port `' + err.port +
		          '\'. This service may not be available in the `' + err.region +
		          '\' region.';
		        this.response.error = AWS.util.error(new Error(message), {
		          code: 'UnknownEndpoint',
		          region: err.region,
		          hostname: err.hostname,
		          retryable: true,
		          originalError: err
		        });
		      }
		    });
		  }),

		  Logger: new SequentialExecutor().addNamedListeners(function(add) {
		    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
		      var req = resp.request;
		      var logger = req.service.config.logger;
		      if (!logger) return;
		      function filterSensitiveLog(inputShape, shape) {
		        if (!shape) {
		          return shape;
		        }
		        if (inputShape.isSensitive) {
		          return '***SensitiveInformation***';
		        }
		        switch (inputShape.type) {
		          case 'structure':
		            var struct = {};
		            AWS.util.each(shape, function(subShapeName, subShape) {
		              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
		                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
		              } else {
		                struct[subShapeName] = subShape;
		              }
		            });
		            return struct;
		          case 'list':
		            var list = [];
		            AWS.util.arrayEach(shape, function(subShape, index) {
		              list.push(filterSensitiveLog(inputShape.member, subShape));
		            });
		            return list;
		          case 'map':
		            var map = {};
		            AWS.util.each(shape, function(key, value) {
		              map[key] = filterSensitiveLog(inputShape.value, value);
		            });
		            return map;
		          default:
		            return shape;
		        }
		      }

		      function buildMessage() {
		        var time = resp.request.service.getSkewCorrectedDate().getTime();
		        var delta = (time - req.startTime.getTime()) / 1000;
		        var ansi = logger.isTTY ? true : false;
		        var status = resp.httpResponse.statusCode;
		        var censoredParams = req.params;
		        if (
		          req.service.api.operations &&
		              req.service.api.operations[req.operation] &&
		              req.service.api.operations[req.operation].input
		        ) {
		          var inputShape = req.service.api.operations[req.operation].input;
		          censoredParams = filterSensitiveLog(inputShape, req.params);
		        }
		        var params = __webpack_require__(52).inspect(censoredParams, true, null);
		        var message = '';
		        if (ansi) message += '\x1B[33m';
		        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
		        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
		        if (ansi) message += '\x1B[0;1m';
		        message += ' ' + AWS.util.string.lowerFirst(req.operation);
		        message += '(' + params + ')';
		        if (ansi) message += '\x1B[0m';
		        return message;
		      }

		      var line = buildMessage();
		      if (typeof logger.log === 'function') {
		        logger.log(line);
		      } else if (typeof logger.write === 'function') {
		        logger.write(line + '\n');
		      }
		    });
		  }),

		  Json: new SequentialExecutor().addNamedListeners(function(add) {
		    var svc = __webpack_require__(18);
		    add('BUILD', 'build', svc.buildRequest);
		    add('EXTRACT_DATA', 'extractData', svc.extractData);
		    add('EXTRACT_ERROR', 'extractError', svc.extractError);
		  }),

		  Rest: new SequentialExecutor().addNamedListeners(function(add) {
		    var svc = __webpack_require__(26);
		    add('BUILD', 'build', svc.buildRequest);
		    add('EXTRACT_DATA', 'extractData', svc.extractData);
		    add('EXTRACT_ERROR', 'extractError', svc.extractError);
		  }),

		  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
		    var svc = __webpack_require__(27);
		    add('BUILD', 'build', svc.buildRequest);
		    add('EXTRACT_DATA', 'extractData', svc.extractData);
		    add('EXTRACT_ERROR', 'extractError', svc.extractError);
		    add('UNSET_CONTENT_LENGTH', 'afterBuild', svc.unsetContentLength);
		  }),

		  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
		    var svc = __webpack_require__(28);
		    add('BUILD', 'build', svc.buildRequest);
		    add('EXTRACT_DATA', 'extractData', svc.extractData);
		    add('EXTRACT_ERROR', 'extractError', svc.extractError);
		  }),

		  Query: new SequentialExecutor().addNamedListeners(function(add) {
		    var svc = __webpack_require__(22);
		    add('BUILD', 'build', svc.buildRequest);
		    add('EXTRACT_DATA', 'extractData', svc.extractData);
		    add('EXTRACT_ERROR', 'extractError', svc.extractError);
		  })
		};

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

	/***/ }),
	/* 51 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {var AWS = __webpack_require__(1);
		var util = __webpack_require__(2);
		var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

		/**
		 * Generate key (except resources and operation part) to index the endpoints in the cache
		 * If input shape has endpointdiscoveryid trait then use
		 *   accessKey + operation + resources + region + service as cache key
		 * If input shape doesn't have endpointdiscoveryid trait then use
		 *   accessKey + region + service as cache key
		 * @return [map<String,String>] object with keys to index endpoints.
		 * @api private
		 */
		function getCacheKey(request) {
		  var service = request.service;
		  var api = service.api || {};
		  var operations = api.operations;
		  var identifiers = {};
		  if (service.config.region) {
		    identifiers.region = service.config.region;
		  }
		  if (api.serviceId) {
		    identifiers.serviceId = api.serviceId;
		  }
		  if (service.config.credentials.accessKeyId) {
		    identifiers.accessKeyId = service.config.credentials.accessKeyId;
		  }
		  return identifiers;
		}

		/**
		 * Recursive helper for marshallCustomIdentifiers().
		 * Looks for required string input members that have 'endpointdiscoveryid' trait.
		 * @api private
		 */
		function marshallCustomIdentifiersHelper(result, params, shape) {
		  if (!shape || params === undefined || params === null) return;
		  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
		    util.arrayEach(shape.required, function(name) {
		      var memberShape = shape.members[name];
		      if (memberShape.endpointDiscoveryId === true) {
		        var locationName = memberShape.isLocationName ? memberShape.name : name;
		        result[locationName] = String(params[name]);
		      } else {
		        marshallCustomIdentifiersHelper(result, params[name], memberShape);
		      }
		    });
		  }
		}

		/**
		 * Get custom identifiers for cache key.
		 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
		 * @param [object] request object
		 * @param [object] input shape of the given operation's api
		 * @api private
		 */
		function marshallCustomIdentifiers(request, shape) {
		  var identifiers = {};
		  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
		  return identifiers;
		}

		/**
		 * Call endpoint discovery operation when it's optional.
		 * When endpoint is available in cache then use the cached endpoints. If endpoints
		 * are unavailable then use regional endpoints and call endpoint discovery operation
		 * asynchronously. This is turned off by default.
		 * @param [object] request object
		 * @api private
		 */
		function optionalDiscoverEndpoint(request) {
		  var service = request.service;
		  var api = service.api;
		  var operationModel = api.operations ? api.operations[request.operation] : undefined;
		  var inputShape = operationModel ? operationModel.input : undefined;

		  var identifiers = marshallCustomIdentifiers(request, inputShape);
		  var cacheKey = getCacheKey(request);
		  if (Object.keys(identifiers).length > 0) {
		    cacheKey = util.update(cacheKey, identifiers);
		    if (operationModel) cacheKey.operation = operationModel.name;
		  }
		  var endpoints = AWS.endpointCache.get(cacheKey);
		  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
		    //endpoint operation is being made but response not yet received
		    //or endpoint operation just failed in 1 minute
		    return;
		  } else if (endpoints && endpoints.length > 0) {
		    //found endpoint record from cache
		    request.httpRequest.updateEndpoint(endpoints[0].Address);
		  } else {
		    //endpoint record not in cache or outdated. make discovery operation
		    var endpointRequest = service.makeRequest(api.endpointOperation, {
		      Operation: operationModel.name,
		      Identifiers: identifiers,
		    });
		    addApiVersionHeader(endpointRequest);
		    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
		    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
		    //put in a placeholder for endpoints already requested, prevent
		    //too much in-flight calls
		    AWS.endpointCache.put(cacheKey, [{
		      Address: '',
		      CachePeriodInMinutes: 1
		    }]);
		    endpointRequest.send(function(err, data) {
		      if (data && data.Endpoints) {
		        AWS.endpointCache.put(cacheKey, data.Endpoints);
		      } else if (err) {
		        AWS.endpointCache.put(cacheKey, [{
		          Address: '',
		          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
		        }]);
		      }
		    });
		  }
		}

		var requestQueue = {};

		/**
		 * Call endpoint discovery operation when it's required.
		 * When endpoint is available in cache then use cached ones. If endpoints are
		 * unavailable then SDK should call endpoint operation then use returned new
		 * endpoint for the api call. SDK will automatically attempt to do endpoint
		 * discovery. This is turned off by default
		 * @param [object] request object
		 * @api private
		 */
		function requiredDiscoverEndpoint(request, done) {
		  var service = request.service;
		  var api = service.api;
		  var operationModel = api.operations ? api.operations[request.operation] : undefined;
		  var inputShape = operationModel ? operationModel.input : undefined;

		  var identifiers = marshallCustomIdentifiers(request, inputShape);
		  var cacheKey = getCacheKey(request);
		  if (Object.keys(identifiers).length > 0) {
		    cacheKey = util.update(cacheKey, identifiers);
		    if (operationModel) cacheKey.operation = operationModel.name;
		  }
		  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
		  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
		  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
		    //endpoint operation is being made but response not yet received
		    //push request object to a pending queue
		    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
		    requestQueue[cacheKeyStr].push({request: request, callback: done});
		    return;
		  } else if (endpoints && endpoints.length > 0) {
		    request.httpRequest.updateEndpoint(endpoints[0].Address);
		    done();
		  } else {
		    var endpointRequest = service.makeRequest(api.endpointOperation, {
		      Operation: operationModel.name,
		      Identifiers: identifiers,
		    });
		    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
		    addApiVersionHeader(endpointRequest);

		    //put in a placeholder for endpoints already requested, prevent
		    //too much in-flight calls
		    AWS.endpointCache.put(cacheKeyStr, [{
		      Address: '',
		      CachePeriodInMinutes: 60 //long-live cache
		    }]);
		    endpointRequest.send(function(err, data) {
		      if (err) {
		        request.response.error = util.error(err, { retryable: false });
		        AWS.endpointCache.remove(cacheKey);

		        //fail all the pending requests in batch
		        if (requestQueue[cacheKeyStr]) {
		          var pendingRequests = requestQueue[cacheKeyStr];
		          util.arrayEach(pendingRequests, function(requestContext) {
		            requestContext.request.response.error = util.error(err, { retryable: false });
		            requestContext.callback();
		          });
		          delete requestQueue[cacheKeyStr];
		        }
		      } else if (data) {
		        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
		        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

		        //update the endpoint for all the pending requests in batch
		        if (requestQueue[cacheKeyStr]) {
		          var pendingRequests = requestQueue[cacheKeyStr];
		          util.arrayEach(pendingRequests, function(requestContext) {
		            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
		            requestContext.callback();
		          });
		          delete requestQueue[cacheKeyStr];
		        }
		      }
		      done();
		    });
		  }
		}

		/**
		 * add api version header to endpoint operation
		 * @api private
		 */
		function addApiVersionHeader(endpointRequest) {
		  var api = endpointRequest.service.api;
		  var apiVersion = api.apiVersion;
		  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
		    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
		  }
		}

		/**
		 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
		 * endpoint from cache.
		 * @api private
		 */
		function invalidateCachedEndpoints(response) {
		  var error = response.error;
		  var httpResponse = response.httpResponse;
		  if (error &&
		    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
		  ) {
		    var request = response.request;
		    var operations = request.service.api.operations || {};
		    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
		    var identifiers = marshallCustomIdentifiers(request, inputShape);
		    var cacheKey = getCacheKey(request);
		    if (Object.keys(identifiers).length > 0) {
		      cacheKey = util.update(cacheKey, identifiers);
		      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
		    }
		    AWS.endpointCache.remove(cacheKey);
		  }
		}

		/**
		 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
		 * @param [object] client Service client object.
		 * @api private
		 */
		function hasCustomEndpoint(client) {
		  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
		  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
		    throw util.error(new Error(), {
		      code: 'ConfigurationException',
		      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
		    });
		  };
		  var svcConfig = AWS.config[client.serviceIdentifier] || {};
		  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
		}

		/**
		 * @api private
		 */
		function isFalsy(value) {
		  return ['false', '0'].indexOf(value) >= 0;
		}

		/**
		 * If endpoint discovery should perform for this request when no operation requires endpoint
		 * discovery for the given service.
		 * SDK performs config resolution in order like below:
		 * 1. If set in client configuration.
		 * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.
		 * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.
		 * @param [object] request request object.
		 * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this
		 *  function returns undefined
		 * @api private
		 */
		function resolveEndpointDiscoveryConfig(request) {
		  var service = request.service || {};
		  if (service.config.endpointDiscoveryEnabled !== undefined) {
		    return service.config.endpointDiscoveryEnabled;
		  }

		  //shared ini file is only available in Node
		  //not to check env in browser
		  if (util.isBrowser()) return undefined;

		  // If any of recognized endpoint discovery config env is set
		  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
		    var env = endpointDiscoveryEnabledEnvs[i];
		    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
		      if (process.env[env] === '' || process.env[env] === undefined) {
		        throw util.error(new Error(), {
		          code: 'ConfigurationException',
		          message: 'environmental variable ' + env + ' cannot be set to nothing'
		        });
		      }
		      return !isFalsy(process.env[env]);
		    }
		  }

		  var configFile = {};
		  try {
		    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
		      isConfig: true,
		      filename: process.env[AWS.util.sharedConfigFileEnv]
		    }) : {};
		  } catch (e) {}
		  var sharedFileConfig = configFile[
		    process.env.AWS_PROFILE || AWS.util.defaultProfile
		  ] || {};
		  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
		    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
		      throw util.error(new Error(), {
		        code: 'ConfigurationException',
		        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
		      });
		    }
		    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
		  }
		  return undefined;
		}

		/**
		 * attach endpoint discovery logic to request object
		 * @param [object] request
		 * @api private
		 */
		function discoverEndpoint(request, done) {
		  var service = request.service || {};
		  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

		  var operations = service.api.operations || {};
		  var operationModel = operations[request.operation];
		  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
		  var isEnabled = resolveEndpointDiscoveryConfig(request);
		  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
		  if (isEnabled || hasRequiredEndpointDiscovery) {
		    // Once a customer enables endpoint discovery, the SDK should start appending
		    // the string endpoint-discovery to the user-agent on all requests.
		    request.httpRequest.appendToUserAgent('endpoint-discovery');
		  }
		  switch (isEndpointDiscoveryRequired) {
		    case 'OPTIONAL':
		      if (isEnabled || hasRequiredEndpointDiscovery) {
		        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery
		        // by default for all operations of that service, including operations where endpoint discovery is optional.
		        optionalDiscoverEndpoint(request);
		        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
		      }
		      done();
		      break;
		    case 'REQUIRED':
		      if (isEnabled === false) {
		        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,
		        // then the SDK must return a clear and actionable exception.
		        request.response.error = util.error(new Error(), {
		          code: 'ConfigurationException',
		          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation +
		                    '() requires it. Please check your configurations.'
		        });
		        done();
		        break;
		      }
		      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
		      requiredDiscoverEndpoint(request, done);
		      break;
		    case 'NULL':
		    default:
		      done();
		      break;
		  }
		}

		module.exports = {
		  discoverEndpoint: discoverEndpoint,
		  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
		  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
		  marshallCustomIdentifiers: marshallCustomIdentifiers,
		  getCacheKey: getCacheKey,
		  invalidateCachedEndpoint: invalidateCachedEndpoints,
		};

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

	/***/ }),
	/* 52 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
		  function getOwnPropertyDescriptors(obj) {
		    var keys = Object.keys(obj);
		    var descriptors = {};
		    for (var i = 0; i < keys.length; i++) {
		      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
		    }
		    return descriptors;
		  };

		var formatRegExp = /%[sdj%]/g;
		exports.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }

		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};


		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports.deprecate = function(fn, msg) {
		  if (typeof process !== 'undefined' && process.noDeprecation === true) {
		    return fn;
		  }

		  // Allow for deprecating things in the process of starting up.
		  if (typeof process === 'undefined') {
		    return function() {
		      return exports.deprecate(fn, msg).apply(this, arguments);
		    };
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		};


		var debugs = {};
		var debugEnvRegex = /^$/;

		if (process.env.NODE_DEBUG) {
		  var debugEnv = process.env.NODE_DEBUG;
		  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
		    .replace(/\*/g, '.*')
		    .replace(/,/g, '$|^')
		    .toUpperCase();
		  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
		}
		exports.debuglog = function(set) {
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (debugEnvRegex.test(set)) {
		      var pid = process.pid;
		      debugs[set] = function() {
		        var msg = exports.format.apply(exports, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};


		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports.inspect = inspect;


		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};

		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};


		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];

		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}


		function stylizeNoColor(str, styleType) {
		  return str;
		}


		function arrayToHash(array) {
		  var hash = {};

		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });

		  return hash;
		}


		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }

		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }

		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);

		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }

		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }

		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }

		  var base = '', array = false, braces = ['{', '}'];

		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }

		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }

		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }

		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }

		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }

		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }

		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }

		  ctx.seen.push(value);

		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }

		  ctx.seen.pop();

		  return reduceToSingleString(output, base, braces);
		}


		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}


		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}


		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}


		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').slice(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.slice(1, -1);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }

		  return name + ': ' + str;
		}


		function reduceToSingleString(output, base, braces) {
		  var numLinesEst = 0;
		  var length = output.reduce(function(prev, cur) {
		    numLinesEst++;
		    if (cur.indexOf('\n') >= 0) numLinesEst++;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);

		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }

		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}


		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		exports.types = __webpack_require__(53);

		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;

		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports.isRegExp = isRegExp;
		exports.types.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports.isObject = isObject;

		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports.isDate = isDate;
		exports.types.isDate = isDate;

		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports.isError = isError;
		exports.types.isNativeError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports.isPrimitive = isPrimitive;

		exports.isBuffer = __webpack_require__(71);

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}


		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}


		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];

		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}


		// log is just a thin wrapper to console.log that prepends a timestamp
		exports.log = function() {
		  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
		};


		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports.inherits = __webpack_require__(72);

		exports._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;

		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};

		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

		exports.promisify = function promisify(original) {
		  if (typeof original !== 'function')
		    throw new TypeError('The "original" argument must be of type Function');

		  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
		    var fn = original[kCustomPromisifiedSymbol];
		    if (typeof fn !== 'function') {
		      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
		    }
		    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		      value: fn, enumerable: false, writable: false, configurable: true
		    });
		    return fn;
		  }

		  function fn() {
		    var promiseResolve, promiseReject;
		    var promise = new Promise(function (resolve, reject) {
		      promiseResolve = resolve;
		      promiseReject = reject;
		    });

		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    args.push(function (err, value) {
		      if (err) {
		        promiseReject(err);
		      } else {
		        promiseResolve(value);
		      }
		    });

		    try {
		      original.apply(this, args);
		    } catch (err) {
		      promiseReject(err);
		    }

		    return promise;
		  }

		  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

		  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		    value: fn, enumerable: false, writable: false, configurable: true
		  });
		  return Object.defineProperties(
		    fn,
		    getOwnPropertyDescriptors(original)
		  );
		}

		exports.promisify.custom = kCustomPromisifiedSymbol

		function callbackifyOnRejected(reason, cb) {
		  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
		  // Because `null` is a special error value in callbacks which means "no error
		  // occurred", we error-wrap so the callback consumer can distinguish between
		  // "the promise rejected with null" or "the promise fulfilled with undefined".
		  if (!reason) {
		    var newReason = new Error('Promise was rejected with a falsy value');
		    newReason.reason = reason;
		    reason = newReason;
		  }
		  return cb(reason);
		}

		function callbackify(original) {
		  if (typeof original !== 'function') {
		    throw new TypeError('The "original" argument must be of type Function');
		  }

		  // We DO NOT return the promise as it gives the user a false sense that
		  // the promise is actually somehow related to the callback's execution
		  // and that the callback throwing will reject the promise.
		  function callbackified() {
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }

		    var maybeCb = args.pop();
		    if (typeof maybeCb !== 'function') {
		      throw new TypeError('The last argument must be of type Function');
		    }
		    var self = this;
		    var cb = function() {
		      return maybeCb.apply(self, arguments);
		    };
		    // In true node style we process the callback on `nextTick` with all the
		    // implications (stack, `uncaughtException`, `async_hooks`)
		    original.apply(this, args)
		      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
		            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
		  }

		  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		  Object.defineProperties(callbackified,
		                          getOwnPropertyDescriptors(original));
		  return callbackified;
		}
		exports.callbackify = callbackify;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

	/***/ }),
	/* 53 */
	/***/ (function(module, exports, __webpack_require__) {

		// Currently in sync with Node.js lib/internal/util/types.js
		// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

		'use strict';

		var isArgumentsObject = __webpack_require__(54);
		var isGeneratorFunction = __webpack_require__(64);
		var whichTypedArray = __webpack_require__(65);
		var isTypedArray = __webpack_require__(70);

		function uncurryThis(f) {
		  return f.call.bind(f);
		}

		var BigIntSupported = typeof BigInt !== 'undefined';
		var SymbolSupported = typeof Symbol !== 'undefined';

		var ObjectToString = uncurryThis(Object.prototype.toString);

		var numberValue = uncurryThis(Number.prototype.valueOf);
		var stringValue = uncurryThis(String.prototype.valueOf);
		var booleanValue = uncurryThis(Boolean.prototype.valueOf);

		if (BigIntSupported) {
		  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
		}

		if (SymbolSupported) {
		  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
		}

		function checkBoxedPrimitive(value, prototypeValueOf) {
		  if (typeof value !== 'object') {
		    return false;
		  }
		  try {
		    prototypeValueOf(value);
		    return true;
		  } catch(e) {
		    return false;
		  }
		}

		exports.isArgumentsObject = isArgumentsObject;
		exports.isGeneratorFunction = isGeneratorFunction;
		exports.isTypedArray = isTypedArray;

		// Taken from here and modified for better browser support
		// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
		function isPromise(input) {
			return (
				(
					typeof Promise !== 'undefined' &&
					input instanceof Promise
				) ||
				(
					input !== null &&
					typeof input === 'object' &&
					typeof input.then === 'function' &&
					typeof input.catch === 'function'
				)
			);
		}
		exports.isPromise = isPromise;

		function isArrayBufferView(value) {
		  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
		    return ArrayBuffer.isView(value);
		  }

		  return (
		    isTypedArray(value) ||
		    isDataView(value)
		  );
		}
		exports.isArrayBufferView = isArrayBufferView;


		function isUint8Array(value) {
		  return whichTypedArray(value) === 'Uint8Array';
		}
		exports.isUint8Array = isUint8Array;

		function isUint8ClampedArray(value) {
		  return whichTypedArray(value) === 'Uint8ClampedArray';
		}
		exports.isUint8ClampedArray = isUint8ClampedArray;

		function isUint16Array(value) {
		  return whichTypedArray(value) === 'Uint16Array';
		}
		exports.isUint16Array = isUint16Array;

		function isUint32Array(value) {
		  return whichTypedArray(value) === 'Uint32Array';
		}
		exports.isUint32Array = isUint32Array;

		function isInt8Array(value) {
		  return whichTypedArray(value) === 'Int8Array';
		}
		exports.isInt8Array = isInt8Array;

		function isInt16Array(value) {
		  return whichTypedArray(value) === 'Int16Array';
		}
		exports.isInt16Array = isInt16Array;

		function isInt32Array(value) {
		  return whichTypedArray(value) === 'Int32Array';
		}
		exports.isInt32Array = isInt32Array;

		function isFloat32Array(value) {
		  return whichTypedArray(value) === 'Float32Array';
		}
		exports.isFloat32Array = isFloat32Array;

		function isFloat64Array(value) {
		  return whichTypedArray(value) === 'Float64Array';
		}
		exports.isFloat64Array = isFloat64Array;

		function isBigInt64Array(value) {
		  return whichTypedArray(value) === 'BigInt64Array';
		}
		exports.isBigInt64Array = isBigInt64Array;

		function isBigUint64Array(value) {
		  return whichTypedArray(value) === 'BigUint64Array';
		}
		exports.isBigUint64Array = isBigUint64Array;

		function isMapToString(value) {
		  return ObjectToString(value) === '[object Map]';
		}
		isMapToString.working = (
		  typeof Map !== 'undefined' &&
		  isMapToString(new Map())
		);

		function isMap(value) {
		  if (typeof Map === 'undefined') {
		    return false;
		  }

		  return isMapToString.working
		    ? isMapToString(value)
		    : value instanceof Map;
		}
		exports.isMap = isMap;

		function isSetToString(value) {
		  return ObjectToString(value) === '[object Set]';
		}
		isSetToString.working = (
		  typeof Set !== 'undefined' &&
		  isSetToString(new Set())
		);
		function isSet(value) {
		  if (typeof Set === 'undefined') {
		    return false;
		  }

		  return isSetToString.working
		    ? isSetToString(value)
		    : value instanceof Set;
		}
		exports.isSet = isSet;

		function isWeakMapToString(value) {
		  return ObjectToString(value) === '[object WeakMap]';
		}
		isWeakMapToString.working = (
		  typeof WeakMap !== 'undefined' &&
		  isWeakMapToString(new WeakMap())
		);
		function isWeakMap(value) {
		  if (typeof WeakMap === 'undefined') {
		    return false;
		  }

		  return isWeakMapToString.working
		    ? isWeakMapToString(value)
		    : value instanceof WeakMap;
		}
		exports.isWeakMap = isWeakMap;

		function isWeakSetToString(value) {
		  return ObjectToString(value) === '[object WeakSet]';
		}
		isWeakSetToString.working = (
		  typeof WeakSet !== 'undefined' &&
		  isWeakSetToString(new WeakSet())
		);
		function isWeakSet(value) {
		  return isWeakSetToString(value);
		}
		exports.isWeakSet = isWeakSet;

		function isArrayBufferToString(value) {
		  return ObjectToString(value) === '[object ArrayBuffer]';
		}
		isArrayBufferToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  isArrayBufferToString(new ArrayBuffer())
		);
		function isArrayBuffer(value) {
		  if (typeof ArrayBuffer === 'undefined') {
		    return false;
		  }

		  return isArrayBufferToString.working
		    ? isArrayBufferToString(value)
		    : value instanceof ArrayBuffer;
		}
		exports.isArrayBuffer = isArrayBuffer;

		function isDataViewToString(value) {
		  return ObjectToString(value) === '[object DataView]';
		}
		isDataViewToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  typeof DataView !== 'undefined' &&
		  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
		);
		function isDataView(value) {
		  if (typeof DataView === 'undefined') {
		    return false;
		  }

		  return isDataViewToString.working
		    ? isDataViewToString(value)
		    : value instanceof DataView;
		}
		exports.isDataView = isDataView;

		// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
		var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
		function isSharedArrayBufferToString(value) {
		  return ObjectToString(value) === '[object SharedArrayBuffer]';
		}
		function isSharedArrayBuffer(value) {
		  if (typeof SharedArrayBufferCopy === 'undefined') {
		    return false;
		  }

		  if (typeof isSharedArrayBufferToString.working === 'undefined') {
		    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		  }

		  return isSharedArrayBufferToString.working
		    ? isSharedArrayBufferToString(value)
		    : value instanceof SharedArrayBufferCopy;
		}
		exports.isSharedArrayBuffer = isSharedArrayBuffer;

		function isAsyncFunction(value) {
		  return ObjectToString(value) === '[object AsyncFunction]';
		}
		exports.isAsyncFunction = isAsyncFunction;

		function isMapIterator(value) {
		  return ObjectToString(value) === '[object Map Iterator]';
		}
		exports.isMapIterator = isMapIterator;

		function isSetIterator(value) {
		  return ObjectToString(value) === '[object Set Iterator]';
		}
		exports.isSetIterator = isSetIterator;

		function isGeneratorObject(value) {
		  return ObjectToString(value) === '[object Generator]';
		}
		exports.isGeneratorObject = isGeneratorObject;

		function isWebAssemblyCompiledModule(value) {
		  return ObjectToString(value) === '[object WebAssembly.Module]';
		}
		exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

		function isNumberObject(value) {
		  return checkBoxedPrimitive(value, numberValue);
		}
		exports.isNumberObject = isNumberObject;

		function isStringObject(value) {
		  return checkBoxedPrimitive(value, stringValue);
		}
		exports.isStringObject = isStringObject;

		function isBooleanObject(value) {
		  return checkBoxedPrimitive(value, booleanValue);
		}
		exports.isBooleanObject = isBooleanObject;

		function isBigIntObject(value) {
		  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
		}
		exports.isBigIntObject = isBigIntObject;

		function isSymbolObject(value) {
		  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
		}
		exports.isSymbolObject = isSymbolObject;

		function isBoxedPrimitive(value) {
		  return (
		    isNumberObject(value) ||
		    isStringObject(value) ||
		    isBooleanObject(value) ||
		    isBigIntObject(value) ||
		    isSymbolObject(value)
		  );
		}
		exports.isBoxedPrimitive = isBoxedPrimitive;

		function isAnyArrayBuffer(value) {
		  return typeof Uint8Array !== 'undefined' && (
		    isArrayBuffer(value) ||
		    isSharedArrayBuffer(value)
		  );
		}
		exports.isAnyArrayBuffer = isAnyArrayBuffer;

		['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
		  Object.defineProperty(exports, method, {
		    enumerable: false,
		    value: function() {
		      throw new Error(method + ' is not supported in userland');
		    }
		  });
		});


	/***/ }),
	/* 54 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var hasToStringTag = __webpack_require__(55)();
		var callBound = __webpack_require__(57);

		var $toString = callBound('Object.prototype.toString');

		var isStandardArguments = function isArguments(value) {
			if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
				return false;
			}
			return $toString(value) === '[object Arguments]';
		};

		var isLegacyArguments = function isArguments(value) {
			if (isStandardArguments(value)) {
				return true;
			}
			return value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				$toString(value) !== '[object Array]' &&
				$toString(value.callee) === '[object Function]';
		};

		var supportsStandardArguments = (function () {
			return isStandardArguments(arguments);
		}());

		isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

		module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


	/***/ }),
	/* 55 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var hasSymbols = __webpack_require__(56);

		module.exports = function hasToStringTagShams() {
			return hasSymbols() && !!Symbol.toStringTag;
		};


	/***/ }),
	/* 56 */
	/***/ (function(module, exports) {

		'use strict';

		/* eslint complexity: [2, 18], max-statements: [2, 33] */
		module.exports = function hasSymbols() {
			if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
			if (typeof Symbol.iterator === 'symbol') { return true; }

			var obj = {};
			var sym = Symbol('test');
			var symObj = Object(sym);
			if (typeof sym === 'string') { return false; }

			if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
			if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

			// temp disabled per https://github.com/ljharb/object.assign/issues/17
			// if (sym instanceof Symbol) { return false; }
			// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
			// if (!(symObj instanceof Symbol)) { return false; }

			// if (typeof Symbol.prototype.toString !== 'function') { return false; }
			// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

			var symVal = 42;
			obj[sym] = symVal;
			for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
			if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

			if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

			var syms = Object.getOwnPropertySymbols(obj);
			if (syms.length !== 1 || syms[0] !== sym) { return false; }

			if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

			if (typeof Object.getOwnPropertyDescriptor === 'function') {
				var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
				if (d